
fn has<E, F>(arr &Array<_, E>, elem E, equator F) bool {
  i! = 0;
  while (i < arr.len()) {
    if ((equator)(arr[i], elem)) {
      ret true;
    }
    set i = i + 1;
  }
  = false;
}

fn has<E>(arr &Array<_, E>, elem E) bool {
  has(arr, elem, ==)
}

fn has<E, F>(seq &[<_> _ * E], elem E, equator F) bool {
  i! = 0;
  while (i < seq.len()) {
    if ((equator)(seq[i], elem)) {
      ret true;
    }
    set i = i + 1;
  }
  = false;
}

fn has<E>(seq &[<_> _ * E], elem E) bool {
  has(seq, elem, ==)
}

// fn Arr<M, F>(n int, generator &F) Array<M, T>
// rules(M Mutability, T Ref, Prot("__call", (&F, int), T))
// {
//   Array<M>(n, &!IFunction1<mut, int, T>(generator))
// }

fn indices<>(arr &Array<_, _>) Array<imm, int> {
  MakeImmArray(len(arr), {_})
}

fn each<M, N, T, F>(arr A, func F) void
rules(A Ref(_, _, [<M> N * T])) {
  i! = 0;
  l = len(&arr);
  while (i < l) {
    func(arr[i]);
    set i = i + 1;
  }
}

fn eachI<M, N, T, F>(arr A, func F) void
rules(A Ref(_, _, [<M> N * T])) {
  i! = 0;
  l = len(&arr);
  while (i < l) {
    func(i, arr[i]);
    set i = i + 1;
  }
}

fn each<M, T, F>(arr A, func F) void
rules(A Ref(_, _, Array<M, T>)) {
  i! = 0;
  l = len(&arr);
  while (i < l) {
    func(arr[i]);
    set i = i + 1;
  }
}

fn eachI<F>(arr A, func F) void
rules(A Ref(_, _, Array<_, _>)) {
  i! = 0;
  l = len(&arr);
  while (i < l) {
    func(i, arr[i]);
    set i = i + 1;
  }
}

fn toImmArray<N, E, SM>(seq &[<SM> N * E]) Array<imm, E> {
  MakeImmArray(N, { seq[_] })
}

fn MakeArray<T, G>(n int, generator G) Array<mut, T>
rules(
  T Ref,
  G Ref(share | borrow, _, _),
  F Prot = Prot("__call", (G, int), T))
{
  __Array<mut, T, G, F>(n, generator)
}

fn MakeImmArray<G>(n int, generator G) Array<imm, T>
rules(
  T Ref,
  G Ref(share | borrow, _, _),
  F Prot = Prot("__call", (G, int), T))
{
  __Array<imm, T, G, F>(n, generator)
}

fn toImmArray<T>(source &Array<_, T>) Array<imm, &T> {
  MakeImmArray(source.len(), &!{ source[_] })
}

fn toArray<T>(source &Array<_, T>) Array<mut, &T> {
  MakeArray(source.len(), { source[_] })
}
