import v.builtins.arith.*;

fn drop_into<V, S, E, F>(arr [#S]<imm, V>E, consumer &!F) void
rules(Prot("__call", Refs(&!F, E), void))
{}

fn drop_into<V, S, E, F>(arr [#S]<mut, V>E, consumer &!F) void
rules(Prot("__call", Refs(&!F, E), void))
extern(vale_static_sized_array_drop_into);

fn drop<V, S, E>(arr [#S]<mut, V>E) void {
  drop_into(arr, {_;});
}
fn drop<V, S, E>(arr [#S]<imm, V>E) void {}

fn drop_into<E, F>(arr []<mut>E, consumer &!F) void
rules(Prot("__call", Refs(&!F, E), void))
{
  while (arr.len() > 0) {
    consumer!(arr!.pop());
  }
  [] = arr;
}
fn drop<E>(arr []<mut>E) void {
  drop_into(arr, {_;});
}

fn drop_into<E, F>(arr []<imm>E, consumer &!F) void
rules(Prot("__call", Refs(&!F, E), void))
{
  i = arr.len() - 1;
  while (i >= 0) {
    consumer!(arr[i]);
    set i = i - 1;
  }
}
fn drop<E>(arr []<imm>E) void {
  drop_into(arr, &!{_;});
}

fn len<M, V, S, E>(arr &[#S]<M, V>E) int extern(vale_static_sized_array_len);

fn len<M, E>(arr &[]<M>E) int extern(vale_runtime_sized_array_len);

fn __free_replaced<V, S, E>(arr @[#S]<imm, V>E) extern(vale_static_sized_array_free);
fn __free_replaced<E>(arr @[]<imm>E) extern(vale_runtime_sized_array_free);

fn capacity<E>(arr &[]<mut>E) int
extern(vale_runtime_sized_array_capacity);

fn push<E>(arr &![]<mut>E, newElement E) void
extern(vale_runtime_sized_array_push);

fn pop<E>(arr &![]<mut>E) E
extern(vale_runtime_sized_array_pop);

fn Array<M, E>(size int) []<M>E
rules(M Mutability = mut, E Ref)
extern(vale_runtime_sized_array_mut_new);

fn Array<M, E, G>(n int, generator G) []<M>E
rules(
  M Mutability = mut,
  T Ref,
  G Ref(share | borrow, _, _),
  F Prot = Prot("__call", Refs(G, int), T))
{
  arr = Array<mut, E>(n);
  i! = 0;
  while (i < n) {
    arr!.push(generator!(i));
    set i = i + 1;
  }
  ret arr;
}

fn Array<M, E, G>(n int, generator G) []<M>E
rules(
  M Mutability = imm,
  E Ref,
  G Ref(share | borrow, _, _),
  F Prot = Prot("__call", Refs(G, int), E))
extern(vale_runtime_sized_array_imm_new);
