import v.builtins.panic.*;

sealed interface Opt<T> where T Ref { }
struct Some<T> where T Ref { value T; }
impl<T> Opt<T> for Some<T>;
struct None<T> where T Ref { }
impl<T> Opt<T> for None<T>;

abstract func isEmpty<T>(virtual opt &Opt<T>) bool;
func isEmpty<T>(opt &None<T> impl Opt<T>) bool { ret true; }
func isEmpty<T>(opt &Some<T> impl Opt<T>) bool { ret false; }

abstract func isEmpty<T>(virtual opt &!Opt<T>) bool;
func isEmpty<T>(opt &!None<T> impl Opt<T>) bool { ret true; }
func isEmpty<T>(opt &!Some<T> impl Opt<T>) bool { ret false; }

abstract func isEmpty<T>(virtual opt Opt<T>) bool;
func isEmpty<T>(opt None<T> impl Opt<T>) bool { ret true; }
func isEmpty<T>(opt Some<T> impl Opt<T>) bool { ret false; }

abstract func get<T>(virtual opt Opt<T>) T;
func get<T>(opt None<T> impl Opt<T>) T { panic("Called get() on a None!"); }
func get<T>(opt Some<T> impl Opt<T>) T {
  [value] = opt;
  ret value;
}

abstract func get<T>(virtual opt &Opt<T>) *T;
func get<T>(opt &None<T> impl Opt<T>) *T { panic("Called get() on a None!"); }
func get<T>(opt &Some<T> impl Opt<T>) *T { ret *opt.value; }
// Itd be nice to abstract over permission
abstract func get<T>(virtual opt &!Opt<T>) *!T;
func get<T>(opt &!None<T> impl Opt<T>) *!T { ret panic("Called get() on a None!"); }
func get<T>(opt &!Some<T> impl Opt<T>) *!T { ret *!opt.value; }
