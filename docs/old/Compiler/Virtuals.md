#### Simple Override

Rust:

> trait IUnit {
>
> fn getMaxHp(&self) -\> Int;
>
> }
>
> struct Marine { hp: Int }
>
> impl Marine for IUnit {
>
> fn getMaxHp(&self) -\> Int {
>
> return self.hp;
>
> }
>
> }

V\'s more common, sugary way to do it:

> interface IUnit {
>
> fn getMaxHp(this: virtual &IUnit): Int;
>
> }
>
> struct Marine {
>
> extends IUnit;
>
> hp: Int;
>
> fn getMaxHp(&this for IUnit) { this.hp }
>
> }

#### 

V, without the sugar:

> interface IUnit;
>
> fn getMaxHp(this: virtual &IUnit): Int;
>
> struct Marine { hp: Int; }
>
> Marine extends IUnit;
>
> fn getMaxHp(this: &Marine for IUnit) { this.hp }

Alternate syntaxes:

fn getMaxHp(for IUnit &this) { this.hp }

#### Patterns

V\'s way, without a pattern:

> struct Marine {
>
> strength: Int;
>
> alive: Bool;
>
> fn getAttackPower(&this) {
>
> if (this.alive) { this.str } else { 0 }
>
> }
>
> }

V\'s way, with a pattern:

> struct Marine {
>
> strength: Int;
>
> alive: Bool;
>
> fn getAttackPower(&this(str, true)) { str }
>
> fn getAttackPower(&this(\_, false)) { 0 }
>
> }

#### 

V, after patterns are lowered to regular methods.

> struct Marine {
>
> strength: Int;
>
> alive: Bool;
>
> }
>
> fn getAttackPower(this: &Marine) {
>
> if (this.alive == true) {
>
> getAttackPower**1**(this);
>
> } else {
>
> getAttackPower**2**(this);
>
> }
>
> }
>
> fn getAttackPower**1**(this: &Marine) { this.str }
>
> fn getAttackPower**2**(this: &Marine) { 0 }

Note: No two cases will be allowed to overlap.

It would be really nice if we could unity pattern syntax with
multimethods.

#### Multimethods

V\'s more common, sugary way to do it:

> sealed interface IAttackable;
>
> struct Player {
>
> extends IAttackable;
>
> hp: Int;
>
> }
>
> struct Goblin {
>
> extends IAttackable;
>
> hp: Int;
>
> }
>
> interface IAttacker {
>
> fn attack(virtual &this, victim: virtual &IAttackable);
>
> }
>
> struct Sword {
>
> extends IAttacker;
>
> damage: Int;
>
> fn attack(&this for IAttacker, victim: &Player for IAttackable) {
>
> victim.hp -= this.damage;
>
> }
>
> fn attack(&this for IAttacker, victim: &Goblin for IAttackable) {
>
> victim.hp -= this.damage \* 2; // extra damage to goblin
>
> }
>
> }
>
> struct Axe {
>
> extends IAttacker;
>
> damage: Int;
>
> fn attack(&this for IAttacker, victim: &Player for IAttackable) {
>
> victim.hp = victim.hp -= this.damage;
>
> }
>
> fn attack(&this for IAttacker, victim: &Goblin for IAttackable) {
>
> victim.hp += 3; // an axe hit heals goblins because of course it does
>
> }
>
> }

V, without the sugar:

> sealed interface IAttackable;
>
> struct Player { hp: Int; }
>
> Player extends IAttackable;
>
> struct Goblin { hp: Int; }
>
> Goblin extends IAttackable;
>
> interface IAttacker;
>
> fn attack(this: virtual &IAttacker, victim: virtual &IAttackable);
>
> struct Sword { damage: Int; }
>
> Sword extends IAttacker;
>
> fn attack(this: &Sword for IAttacker, victim: &Player for IAttackable)
> {
>
> victim.hp -= this.damage;
>
> }
>
> fn attack(&this for IAttacker, victim: &Goblin for IAttackable) {
>
> victim.hp -= this.damage \* 2; // extra damage to goblin
>
> }
>
> struct Axe { damage: Int; }
>
> Axe extends IAttacker;
>
> fn attack(this: &Axe for IAttacker, victim: &Player for IAttackable) {
>
> victim.hp = victim.hp -= this.damage;
>
> }
>
> fn attack(this: &Axe for IAttacker, victim: &Goblin for IAttackable) {
>
> victim.hp += 3; // an axe hit heals goblins because of course it does
>
> }

V, after multimethods are lowered to regular methods.

Gray = used to be there, not anymore.

Blue = autogenerated.

> sealed interface IAttackable;
>
> struct Player { hp: Int; }
>
> Player extends IAttackable;
>
> struct Goblin { hp: Int; }
>
> Goblin extends IAttackable;
>
> fn visit(this: virtual &IAttackable, visitor: &IAttackableVisitor);
>
> fn visit(this: &Player for IAttackable, visitor: &IAttackableVisitor)
> { visitor.visit(this); }
>
> fn visit(this: &Goblin for IAttackable, visitor: &IAttackableVisitor)
> { visitor.visit(this); }
>
> interface IAttackableVisitor;
>
> fn visit(visitor: virtual &IAttackableVisitor, obj: &Player);
>
> fn visit(visitor: virtual &IAttackableVisitor, obj: &Goblin);
>
> interface IAttacker;
>
> fn attack(this: virtual &IAttacker, victim: virtual &IAttackable);
>
> struct Sword { damage: Int; }
>
> Sword extends IAttacker;
>
> struct SwordAttackVisitor { this: &Sword } // other params would go
> here
>
> SwordAttackVisitor extends IAttackableVisitor;
>
> fn attack(this: &Sword for IAttacker, victim: &IAttackable) {
>
> SwordAttackVisitor(this).visit(victim);
>
> }
>
> fn visit(visitor: &SwordAttackVisitor for IAttackableVisitor, obj:
> &Player) {
>
> attack(visitor.this, obj);
>
> }
>
> fn visit(visitor: &SwordAttackVisitor for IAttackableVisitor, obj:
> &Goblin) {
>
> attack(visitor.this, obj);
>
> }
>
> fn attack(this: &Sword for IAttacker, victim: &Player for IAttackable)
> {
>
> victim.hp -= this.damage;
>
> }
>
> fn attack(&this for IAttacker, victim: &Goblin for IAttackable) {
>
> victim.hp -= this.damage \* 2; // extra damage to goblin
>
> }
>
> struct Axe { damage: Int; }
>
> Axe extends IAttacker;
>
> struct AxeAttackVisitor { this: &Axe } // other params would go here
>
> AxeAttackVisitor extends IAttackableVisitor;
>
> fn attack(this: &Axe for IAttacker, victim: &IAttackable) {
>
> SwordAttackVisitor(this).visit(victim);
>
> }
>
> fn visit(visitor: &AxeAttackVisitor for IAttackableVisitor, obj:
> &Player) {
>
> attack(visitor.this, obj);
>
> }
>
> fn visit(visitor: &AxeAttackVisitor for IAttackableVisitor, obj:
> &Goblin) {
>
> attack(visitor.this, obj);
>
> }
>
> fn attack(this: &Axe for IAttacker, victim: &Player for IAttackable) {
>
> victim.hp = victim.hp -= this.damage;
>
> }
>
> fn attack(this: &Axe for IAttacker, victim: &Goblin for IAttackable) {
>
> victim.hp += 3; // an axe hit heals goblins because of course it does
>
> }

Note: we dont need to use a visitor! Eventually we could instead use an
integer. It could make it easier to unify with pattern matching. Might
give better performance too since we won\'t need to put arguments inside
a visitor struct.

Besides, we don\'t want to use visitors for match statements inside
functions (means we can\'t break, continue, return, access locals as
easily) so... why would we want to use them here?

#### Unifying and Simplifying

From V\'s sugary multimethods example above:

> struct Sword {
>
> extends IAttacker;
>
> damage: Int;
>
> fn attack(&this for IAttacker, victim: &Player for IAttackable) {
>
> victim.hp -= this.damage;
>
> }
>
> fn attack(&this for IAttacker, victim: &Goblin for IAttackable) {
>
> victim.hp -= this.damage \* 2; // extra damage to goblin
>
> }
>
> }

Note how we don\'t actually **need** the \"for IAttackable\" part. We
can know that the second argument is an IAttackable by looking at
IAttacker.attack\'s signature. We can simplify to:

> struct Sword {
>
> extends IAttacker;
>
> damage: Int;
>
> fn attack(&this for IAttacker, victim: &Player) {
>
> victim.hp -= this.damage;
>
> }
>
> fn attack(&this for IAttacker, victim: &Goblin) {
>
> victim.hp -= this.damage \* 2; // extra damage to goblin
>
> }
>
> }

Now, let\'s take the second \"virtual\" out of the declaration:

> interface IAttacker;
>
> fn attack(this: virtual &IAttacker, victim: virtual &IAttackable);

Let\'s also change the pattern example to have a declaration:

> struct Marine {
>
> strength: Int;
>
> alive: Bool;
>
> fn getAttackPower(&this): Int;
>
> fn getAttackPower(&this(str, true)) { str }
>
> fn getAttackPower(&this(\_, false)) { 0 }
>
> }

And now we\'ll put virtual in front of the struct this param:

> struct Marine {
>
> strength: Int;
>
> alive: Bool;
>
> virtual fn getAttackPower(virtual &this): Int;
>
> fn getAttackPower(&this(str, true)) { str }
>
> fn getAttackPower(&this(\_, false)) { 0 }
>
> }

Since it\'s not an interface, it\'ll know that we\'re gonna pattern
match it.

Now we\'ve unified the syntax. Specifically:

-   Only do itable calls on the first virtual open (non-sealed)
    > interface. We can\'t allow methods that do virtual on more than
    > one open interface.

-   Everything else (sealed interfaces, structs) uses pattern matching
    > or a visitor (though we might make visitor use indices too to make
    > it like pattern matching).

todo: rewrite all the above without the visitor pattern.

can we somehow pattern match on what components an object has?

if we\'re doing an electric attack, we might want to match on a victim
who has a bomb in their backpack.

interface IAttackable {

fn getComponents(): Set:IComponent;

}

fn IAttackableHasComponent:T(this: &IAttackable): Option:\[T\] {

// scala ish, convert to V

this.getComponents().collect({

case t : T =\> t

}).headOption

}

victim match {

if IAttackableHasComponent:IBomb(\[bomb\]) {

... do stuff

}

}

that\'s the answer.

the only tricky part now is that we have to generate a Set:IComponent
efficiently. and it\'s mutable, which kind of sucks.

perhaps if a map was internall implemented as a parallel array of keys
and values, it would be efficient to get the keys.

maybe we can offer both?

or perhaps this can be a special set that is sorted by class. a
map:(class, set:T). maybe we can make it work well with collect() too.

can\'t use extractors in function signature patterns because we can\'t
tell whether theyre overlapping or not.

#### Implementation

> interface IUnit;
>
> fn getMaxHp(this: virtual &IUnit): Int;
>
> struct Marine { hp: Int; }
>
> Marine extends IUnit;
>
> fn getMaxHp(this: &Marine for IUnit) { this.hp }

First, some reminders:

-   Depending on how we do pattern matching, we might use the
    > \"virtual\" keyword for that too. In this section, virtual only
    > refers to the actual \"dynamic dispatch via itable\" kind of
    > virtual, the kind that can be done between modules.

-   There will only ever be one virtual parameter for any method.

-   When do structs and interfaces become known to the compiler? In
    > other words, when does the first StructRef2/StructDef2 or
    > InterfaceRef2/InterfaceDef2 come into existence for a certain
    > struct or interface? Answer: when one of these things happens:

    -   It\'s ordinary and we encounter it at the top level.

    -   It\'s templated and we encounter it:

        -   In a let\'s pattern, like let x: IOption:Int = ...;

        -   In a parameter: fn doThing(IOption:#T);

        -   In a return type, like fn Some(val: #T): Some:#T { ... }

-   When do functions become known to the compiler? In other words, when
    > does the first Prototype2 come into existence for a certain
    > function? Answer: when one of these things happens:

    -   It\'s ordinary and we encounter it at the top level.

    -   It\'s templated and we call it.

    -   (Someday perhaps) When we select it with a selector, like
        > println(:Int) or exit(:).

Things we gotta do:

-   If we are just calling getMaxHp(Marine(7)); the type is known so we
    > don\'t need to do any itable dispatch. Nothing special here.

-   When we put an abstract function into the temputs, such as
    > getMaxHp(someIUnit); we don\'t know the type so we need to make
    > sure **all** getMaxHp(**any descendant of IUnit)** are evaluated
    > and put into temputs. This is done by
    > **VirtualTemplar.evaluateOverrides**.

-   When we put an interface into the temputs, nothing really needs to
    > happen.

-   When a struct is added to the temputs, we have to find all things
    > that implement it. Then, we\'ll make destructors for them there.
    > StructTemplarCore.makeStruct calls
    > FunctionTemplarMiddleLayer.makeImplDestructor for this.

-   ~~When the temputs learns that a struct implements an interface, we
    > need to find all functions that are virtual on that interface, and
    > evaluate them for this struct. **Not yet sure who will do
    > this.**~~

// There are multiple idestructor overrides for a given struct, which
can

// confuse us.

// They all override different interfaces, but that\'s not factored into
the

// overload templar.

// However, the template arguments are, and idestructor\'s template
argument

// is the interface we\'re overriding.

when we ask overloadtemplar to find something named idestructor that
takes in this struct as a parameter, we\'re not giving it enough to
figure out what the idestructor\'s interface template parameter should
be (and so it cant figure out what the override interface should be). we
can\'t ask overloadtemplar to search for something with the certain
template args\...

though, if we could, perhaps that\'s virtual templates for us?

what we really want is to, for a given struct, add an impl function for
it for every interface it implements. it seemed like feeding it to
overloadtemplar would have worked but it\'s not working out too well for
us. problem was\... when we try to stamp parents and children of an
idestructor, it cant figure out its children. it was looking for who
would be children for this virtual idestructor thing, but it couldnt
tell its children who it was overriding.

other option is to tell overload templar to search for someone that can
override the given interface. almost as if it\'s another criteria
besides name and param types.

#### VirtualTemplar.evaluateOverrides

Let\'s say we already have:

> interface Option:T {}
>
> struct Some:T { val: T };
>
> Some:T isa Option:T;
>
> struct None:T { };
>
> None:T isa Option:T;

and also a function that stamped them:

> fn main() {
>
> let x = Some(5);
>
> let y = None:Int();
>
> \...
>
> }

but then at some point these get added to the global env\...

> fn getOrElse:T(this: virtual Option:T, default: T);
>
> fn getOrElse:T(this: Some:T for Option:T, default: T) { this.val }
>
> fn getOrElse:T(this: None:T for Option:T, default: T) { default }

but they weren\'t stamped yet.

Now, some other function comes along and actually uses it:

> fn something(opt: Option:Int) {
>
> let x = opt.getOrElse(8);
>
> \...
>
> }

Well, we\'ve just stamped

fn getOrElse:T(this: virtual Option:T, default: T);

to specifically be a:

fn getOrElse:Int(this: virtual Option:Int, default: Int);

but now we have to stamp this function for all descendants of
Option:Int.

That fn getOrElse:Int(this: virtual Option:Int, default: Int); is also
known as a **spark header** because it\'s about to spark an explosion of
new methods, in this case, two:

-   fn getOrElse:Int(this: Some:Int for Option:Int, default: Int)

-   fn getOrElse:Int(this: None:Int for Option:Int, default: Int)

\"Templated parent case\"

when we have:

> interface ICallback:T {
>
> fn handle(virtual this, value: T);
>
> }
>
> struct MyThing {
>
> extends ICallback:Int;
>
> fn handle(this override ICallback:Int, value: Int);
>
> }

it\'s the same as:

> interface ICallback:T;
>
> fn handle:T(this: virtual ICallback:T, value: T);
>
> struct MyThing { }
>
> impl MyThing for ICallback:Int;
>
> fn handle(this: MyThing override ICallback:Int, value: Int);

and we encounter and evaluate the handle override, we of course stamped
ICallback:Int but **we never stamped handle:Int**. We need to do that.

WE EVALUATED ALL THE IMPLS FIRST! We know the hierarchies before we
handle any functions! this can drastically simplify what we do. WAIT
nope thats not true. if a struct is templated we wont know its hierarchy
until it\'s stamped. lets mention this somewhere in this doc.

### Must Look In Override Env Too

(MLIOET)

When we call a method like fly(spaceship, 4, 5), we look in spaceship\'s
env.

We need to do that when we\'re looking for a override function\'s parent
abstract function too. Otherwise, in cases like this:

interface MyIFunction1\<P1, R\> rules(P1 Ref, R Ref) {

abstract fn go(virtual this &MyIFunction1\<P1, R\>, param P1) R;

}

struct MyFunc { }

impl MyFunc for MyIFunction1\<Int, Int\>;

fn go(this &MyFunc impl MyIFunction1\<Int, Int\>, param Int) Int {

param \* 2

}

\...when we look for go\'s parent interface, it can\'t find it because
it\'s inside MyIFunction1. So, we need to look in the thing after
\`impl\` there.
