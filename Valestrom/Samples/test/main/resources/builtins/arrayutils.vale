
fn toArray<M, N, E, SM>(seq &[<SM> N * E]) rules(M Mutability) Array<M, E> {
  Array<M, E>(N, &!IFunction1<SM, int, E>((i){ seq[i]}))
}

fn has<E, F>(arr &Array<_, E>, elem E, equator F) bool {
  i! = 0;
  while (i < arr.len()) {
    if ((equator)(arr[i], elem)) {
      ret true;
    }
    mut i = i + 1;
  }
  = false;
}

fn has<E>(arr &Array<_, E>, elem E) bool {
  has(arr, elem, ==)
}

fn has<E, F>(seq &[<_> _ * E], elem E, equator F) bool {
  i! = 0;
  while (i < seq.len()) {
    if ((equator)(seq[i], elem)) {
      ret true;
    }
    mut i = i + 1;
  }
  = false;
}

fn has<E>(seq &[<_> _ * E], elem E) bool {
  has(seq, elem, ==)
}

// fn Arr<M, F>(n int, generator &F) Array<M, T>
// rules(M Mutability, T Ref, Prot("__call", (&F, int), T))
// {
//   Array<M>(n, &!IFunction1<mut, int, T>(generator))
// }

fn MakeArray<F>(n int, generator &F) Array<mut, T>
rules(T Ref, Prot("__call", (&F, int), T))
{
  Array<mut>(n, &!IFunction1<mut, int, T>(generator))
}
fn MakeImmArray<F>(n int, generator &F) Array<imm, T>
rules(T Ref, Prot("__call", (&F, int), T))
{
  Array<imm>(n, &!IFunction1<mut, int, T>(generator))
}

fn indices<>(arr &Array<_, _>) Array<imm, int> {
  MakeImmArray(len(arr), {_})
}

fn each<M, N, T, F>(arr A, func F) void
rules(A Ref(_, _, [<M> N * T])) {
  i! = 0;
  l = len(&arr);
  while (i < l) {
    func(arr[i]);
    mut i = i + 1;
  }
}

fn eacIh<M, N, T, F>(arr A, func F) void
rules(A Ref(_, _, [<M> N * T])) {
  i! = 0;
  l = len(&arr);
  while (i < l) {
    func(i, arr[i]);
    mut i = i + 1;
  }
}

fn each<M, T, F>(arr A, func F) void
rules(A Ref(_, _, Array<M, T>)) {
  i! = 0;
  l = len(&arr);
  while (i < l) {
    func(arr[i]);
    mut i = i + 1;
  }
}

fn eachI<F>(arr A, func F) void
rules(A Ref(_, _, Array<_, _>)) {
  i! = 0;
  l = len(&arr);
  while (i < l) {
    func(i, arr[i]);
    mut i = i + 1;
  }
}
