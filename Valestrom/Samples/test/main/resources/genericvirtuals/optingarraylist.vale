struct List<E> rules(E Ref) {
  array Array<mut, Opt<E>>;
  size int;
}
fn List<E>() rules(E Ref) {
  List<E>(Array<mut, Opt<E>>(0, &IFunction1<mut, int, Opt<E>>((index){ panic()})), 0)
}
fn len<E>(list &List<E>) { list.size }
fn add<E>(list &List<E>, newElement E) {
}
// todo make that return a &E
fn get<E>(list &List<E>, index int) &Opt<E> {
  a = list.array;
  = a[index];
}
fn set<E>(list &List<E>, index int, value E) void {
  mut list.array[index] = Some(value);
}
fn toArray<M, E>(list &List<E>) Array<M, E> rules(M Mutability) {
  Array<M, E>(list.len(), &IFunction1<mut, int, E>((i){ list.get(i).get()}))
}
fn toList<E>(arr &Array<_, E>) List<E> {
  list = List<E>();
  arr each (elem){
    list.add(elem);
  };
  = list;
}

fn each<E, F>(list &List<E>, func F) void {
  i! = 0;
  l = len(&list);
  while (i < l) {
    func(list.get(i).get());
    mut i = i + 1;
  }
}
