
fn toArray<M, N, E, SM>(seq &[<SM> N * E]) rules(M Mutability) {
  Array<M, E>(N, &IFunction1<SM, int, E>((i){ seq[i]}))
}
fn has<E, F>(arr &Array<_, E>, elem E, equator F) bool {
  i = 0;
  while (i < arr.len()) {
    if ((equator)(arr[i], elem)) {
      ret true;
    }
    mut i = i + 1;
  }
  = false;
}
fn has<E>(arr &Array<_, E>, elem E) bool {
  has(arr, elem, ==)
}
fn has<E, F>(seq &[<_> _ * E], elem E, equator F) bool {
  i = 0;
  while (i < seq.len()) {
    if ((equator)(seq[i], elem)) {
      ret true;
    }
    mut i = i + 1;
  }
  = false;
}
fn has<E>(seq &[<_> _ * E], elem E) bool {
  has(seq, elem, ==)
}
fn Arr<M, F>(n int, generator &F) Array<M, T>
rules(M Mutability, T Ref, Prot("__call", (&F, int), T))
{
  Array<M>(n, &IFunction1<mut, int, T>(generator))
}
fn each<M, N, T, F>(arr &[<M> N * T], func F) void {
  i! = 0;
  l = len(&arr);
  while (i < l) {
    func(arr[i]);
    mut i = i + 1;
  }
}
fn each<M, T, F>(arr &Array<M, T>, func F) void {
  i! = 0;
  l = len(&arr);
  while (i < l) {
    func(arr[i]);
    mut i = i + 1;
  }
}
fn indices<>(arr &Array<_, _>) Array<imm, int> {
  Arr<imm>(len(arr), {_})
}
fn eachI<F>(arr &Array<_, _>, func F) void {
  i! = 0;
  l = len(&arr);
  while (i < l) {
    func(i, arr[i]);
    mut i = i + 1;
  }
}
struct List<E> rules(E Ref) {
  array Array<mut, Opt<E>>;
  size int;
}
fn List<E>() rules(E Ref) {
  List<E>(Array<mut, Opt<E>>(0, &IFunction1<mut, int, Opt<E>>((index){ panic()})), 0)
}
fn len<E>(list &List<E>) { list.size }
fn add<E>(list &List<E>, newElement E) {
  if (list.size == list.len()) {
    newLen = if (len(list) == 0) { 1 } else { len(list) * 2 };
    newArray =
        Array<mut, Opt<E>>(newLen, &IFunction1<mut, int, Opt<E>>((index){
          = if (index < len(list)) {
              = (mut list.array[index] = None<E>());
            } else {
              result Opt<E> = None<E>();
              = result;
            }
        }));
    mut list.array = newArray;
  }
  mut list.array[list.size] = Some<E>(newElement);
  mut list.size = list.size + 1;
}
fn get<E>(list &List<E>, index int) &Opt<E> {
  a = list.array;
  = a[index];
}
fn set<E>(list &List<E>, index int, value E) void {
  mut list.array[index] = Some(value);
}
fn toArray<M, E>(list &List<E>) Array<M, E> rules(M Mutability) {
  Array<M, E>(list.len(), &IFunction1<mut, int, E>((i){ list.get(i).get()}))
}
fn toList<E>(arr &Array<_, E>) List<E> {
  list = List<E>();
  arr each (elem){
    list.add(elem);
  };
  = list;
}
fn each<E, F>(list &List<E>, func F) void {
  i! = 0;
  l = len(&list);
  while (i < l) {
    func(list.get(i).get());
    mut i = i + 1;
  }
}
interface Opt<T> rules(T Ref) { }
struct Some<T> rules(T Ref) { value T; }
impl<T> Opt<T> for Some<T>;
struct None<T> rules(T Ref) { }
impl<T> Opt<T> for None<T>;
fn empty?<T>(virtual opt &Opt<T>) bool abstract;
fn empty?<T>(opt &None<T> impl Opt<T>) bool { true }
fn empty?<T>(opt &Some<T> impl Opt<T>) bool { false }
fn get<T>(virtual opt Opt<T>) T abstract;
fn get<T>(opt None<T> impl Opt<T>) T { panic() }
fn get<T>(opt Some<T> impl Opt<T>) T {
  Some<T>(value) = opt;
  = value;
}
fn get<T>(virtual opt &Opt<T>) &T abstract;
fn get<T>(opt &None<T> impl Opt<T>) &T { panic("Called get() on a None!") }
fn get<T>(opt &Some<T> impl Opt<T>) &T { opt.value }
fn getOr<T>(virtual opt &Opt<T>, default T) T abstract;
fn getOr<T>(opt &None<T> impl Opt<T>, default T) T {
  default
}
fn getOr<T>(opt &Some<T> impl Opt<T>, default T) T {
  opt.value
}
fn map<T, R>(virtual opt &Opt<T>, func &IFunction1<mut, &T, R>) Opt<R> abstract;
fn map<T, R>(opt &None<T> impl Opt<T>, func &IFunction1<mut, &T, R>) Opt<R> {
  None<R>()
}
fn map<T, R>(opt &Some<T> impl Opt<T>, func &IFunction1<mut, &T, R>) Opt<R> {
  Some<R>(func(opt.value))
}
fn getSize<T>(virtual opt &Opt<T>) int abstract;
fn getSize<T>(opt &None<T> impl Opt<T>) int { 0 }
fn getSize<T>(opt &Some<T> impl Opt<T>) int { 1 }
struct HashMapNode<K, V> {
  key K;
  value V;
}
struct HashMap<K, V, H, E> {
  hasher H;
  equator E;
  table Array<mut, Opt<HashMapNode<K, V>>>;
  size int;
}
fn HashMap<K, V, H, E>(hasher H, equator E) HashMap<K, V, H, E> {
  HashMap<K, V, H, E>(hasher, equator, 0)
}
fn HashMap<K, V, H, E>(hasher H, equator E, capacity int) HashMap<K, V, H, E> {
  HashMap<K, V>(
      hasher,
      equator,
      Array<mut, Opt<HashMapNode<K, V>>>(
        capacity,
        &IFunction1<mut, int, Opt<HashMapNode<K, V>>>((index){
          opt Opt<HashMapNode<K, V>> = None<HashMapNode<K, V>>();
          = opt;
        })),
      0)
}
fn len<K, V, H, E>(self &HashMap<K, V, H, E>) int { self.size }
fn update<K, V, H, E>(self &HashMap<K, V, H, E>, key K, value V) void {
  hash int = (self.hasher)(key);
  startIndex = abs(hash mod self.table.len());
  index? = findIndexOfKey(self.table, self.equator, startIndex, key);
  if (index?.empty?()) {
    panic("Map doesnt have given key!");
  }
  node = self.table[index?.get()].get();
  mut node.value = value;
}
fn add<K, V, H, E>(map &HashMap<K, V, H, E>, key K, value V) void {
  if (map.has(key)) {
    panic("Map already has given key!");
  }
  if ((map.size + 1) * 2 >= map.table.len()) {
    newSize =
        if (map.table.len() == 0) { 2 }
        else { map.table.len() * 2 };
    newTable =
        Array<mut, Opt<HashMapNode<K, V>>>(
            newSize,
            &IFunction1<mut, int, Opt<HashMapNode<K, V>>>((index){
              opt Opt<HashMapNode<K, V>> = None<HashMapNode<K, V>>();
              = opt;
            }));
    i = 0;
    while (i < map.table.len()) {
      if (map.table[i].empty?()) {
      } else {
        node? = (mut map.table[i] = None<HashMapNode<K, V>>());
        node = get(node?);
        addNodeToTable(&newTable, map.hasher, node);
      }
      mut i = i + 1;
    }
    mut map.table = newTable;
  }
  addNodeToTable(map.table, map.hasher, HashMapNode<K, V>(key, value));
  mut map.size = map.size + 1;
}
fn addNodeToTable<K, V, H>(table &Array<mut, Opt<HashMapNode<K, V>>>, hasher H, node HashMapNode<K, V>) {
  hash int = (hasher)(node.key);
  startIndex = abs(hash mod table.len());
  index = findEmptyIndexForKey(table, startIndex, node.key);
  opt Opt<HashMapNode<K, V>> = Some(node);
  mut table[index] = opt;
}
fn findEmptyIndexForKey<K, V>(table &Array<mut, Opt<HashMapNode<K, V>>>, startIndex int, key K) int {
  i = 0;
  while (i < table.len()) {
    index = (startIndex + i) mod table.len();
    something = table[index];
    if (something.empty?()) {
      ret index;
    }
    mut i = i + 1;
  }
  = panic("findEmptyIndexForKey went past end of table!");
}
fn findIndexOfKey<K, V, E>(table &Array<mut, Opt<HashMapNode<K, V>>>, equator E, startIndex int, key K) Opt<int> {
  i = 0;
  while (i < table.len()) {
    index = (startIndex + i) mod table.len();
    something = table[index];
    if (something.empty?()) {
      ret None<int>();
    }
    node = something.get();
    if ((equator)(node.key, key)) {
      ret Some<int>(index);
    }
    mut i = i + 1;
  }
  = panic("findIndexOfKey went past end of table! len " + str(table.len()) + " and i " + str(i));
}
fn get<K, V, H, E>(self &HashMap<K, V, H, E>, key K) Opt<&V> {
  if (self.table.len() == 0) {
    ret None<&V>();
  }
  hash int = (self.hasher)(key);
  startIndex = abs(hash mod self.table.len());
  index? = findIndexOfKey(self.table, self.equator, startIndex, key);
  if (index?.empty?()) {
    opt Opt<&V> = None<&V>();
    ret opt;
  }
  node = self.table[index?.get()].get();
  opt Opt<&V> = Some<&V>(node.value);
  ret opt;
}
fn has<K, V, H, E>(self &HashMap<K, V, H, E>, key K) bool {
  not(self.get(key).empty?())
}
fn keys<K, V, H, E>(self &HashMap<K, V, H, E>) Array<imm, K> {
  list = List<K>();
  index = 0;
  while (index < self.table.len()) {
    node? = self.table[index];
    if (not(node?.empty?())) {
      list.add(node?.get().key);
    }
    mut index = index + 1;
  }
  = list.toArray<imm>();
}
fn values<K, V, H, E>(self &HashMap<K, V, H, E>) Array<mut, V> {
  list = List<V>();
  index = 0;
  while (index < self.table.len()) {
    node? = self.table[index];
    if (not(node?.empty?())) {
      list.add(node?.get().value);
    }
    mut index = index + 1;
  }
  = list.toArray<mut>();
}
fn innerRemove<K, V, H, E>(
  table &Array<mut, Opt<HashMapNode<K, V>>>,
  hasher H,
  equator E,
  key K)
int {
  hash int = (hasher)(key);
  startIndex = abs(hash mod table.len());
  index? = findIndexOfKey(table, equator, startIndex, key);
  index = index?.get();
  mut table[index] = None<HashMapNode<K, V>>();
  ret index;
}
fn remove<K, V, H, E>(
  map &HashMap<K, V, H, E>,
  key K)
void {
  originalIndex = innerRemove(map.table, map.hasher, map.equator, key);
  mut map.size = map.size - 1;
  i! = 1;
  while (i < map.table.len()) {
    neighborIndex = (originalIndex + i) mod len(map.table);
    neighbor? = (mut map.table[neighborIndex] = None<HashMapNode<K, V>>());
    if (not neighbor?.empty?()) {
      (neighborKey, neighborValue) = neighbor?^.get();
      addNodeToTable(map.table, map.hasher, HashMapNode<K, V>(neighborKey, neighborValue));
    } else {
      drop(neighbor?);
      mut i = map.table.len(); // break
    }
    mut i = i + 1;
  }
}
struct HashSet<K, H, E> {
  hasher H;
  equator E;
  table Array<mut, Opt<K>>;
  size int;
}
fn HashSet<K, H, E>(hasher H, equator E) HashSet<K, H, E> {
  HashSet<K, H, E>(hasher, equator, 0)
}
fn HashSet<K, H, E>(hasher H, equator E, capacity int) HashSet<K, H, E> {
  HashSet<K>(
      hasher,
      equator,
      Array<mut, Opt<K>>(
        capacity,
        &IFunction1<mut, int, Opt<K>>((index){
          opt Opt<K> = None<K>();
          = opt;
        })),
      0)
}
fn HashSet<K, H, E, M, N>(
    valuesKSA &[<M> N * K],
    hasher H,
    equator E)
HashSet<K, H, E> {
  this = HashSet<K, H, E>(hasher, equator, 0);
  each (valuesKSA) (v){
    if (not this.has(v)) {
      this.add(v);
    }
  }
  ret this;
}
fn HashSet<K, H, E, M>(
    valuesArray &Array<M, K>,
    hasher H,
    equator E)
HashSet<K, H, E> {
  this = HashSet<K, H, E>(hasher, equator, 0);
  each (valuesArray) (v){
    if (not this.has(v)) {
      this.add(v);
    }
  }
  ret this;
}
fn len<K, H, E>(set &HashSet<K, H, E>) int { set.size }
fn empty?<K, H, E>(set &HashSet<K, H, E>) bool { set.size == 0 }
fn add<K, H, E>(set &HashSet<K, H, E>, key K) void {
  if (set.has(key)) {
    panic("HashSet already has given key!");
  }
  if ((set.size + 1) * 2 >= set.table.len()) {
    newSize =
        if (set.table.len() == 0) { 2 }
        else { set.table.len() * 2 };
    newTable =
        Array<mut, Opt<K>>(
            newSize,
            &IFunction1<mut, int, Opt<K>>((index){
              opt Opt<K> = None<K>();
              = opt;
            }));
    i = 0;
    while (i < set.table.len()) {
      if (set.table[i].empty?()) {
      } else {
        node? = (mut set.table[i] = None<K>());
        node = get(node?);
        addNodeToHashSetTable(&newTable, set.hasher, node);
      }
      mut i = i + 1;
    }
    mut set.table = newTable;
  }
  addNodeToHashSetTable(set.table, set.hasher, key);
  mut set.size = set.size + 1;
}
fn addNodeToHashSetTable<K, H>(table &Array<mut, Opt<K>>, hasher H, key K) {
  hash int = (hasher)(key);
  startIndex = abs(hash mod table.len());
  index = findEmptyIndexInHashSetForKey(table, startIndex, key);
  opt Opt<K> = Some(key);
  mut table[index] = opt;
}
fn findEmptyIndexInHashSetForKey<K>(table &Array<mut, Opt<K>>, startIndex int, key K) int {
  i = 0;
  while (i < table.len()) {
    index = (startIndex + i) mod table.len();
    something = table[index];
    if (something.empty?()) {
      ret index;
    }
    mut i = i + 1;
  }
  = panic("findEmptyIndexInHashSetForKey went past end of table!");
}
fn findIndexOfKey<K, E>(table &Array<mut, Opt<K>>, equator E, startIndex int, key K) Opt<int> {
  i = 0;
  while (i < table.len()) {
    index = (startIndex + i) mod table.len();
    something = table[index];
    if (something.empty?()) {
      ret None<int>();
    }
    node = something.get();
    if ((equator)(node, key)) {
      ret Some<int>(index);
    }
    mut i = i + 1;
  }
  = panic("findIndexOfKey went past end of table! len " + str(table.len()) + " and i " + str(i));
}
fn get<K, H, E>(self &HashSet<K, H, E>, key K) Opt<K> {
  if (self.table.len() == 0) {
    ret None<K>();
  }
  hash int = (self.hasher)(key);
  startIndex = abs(hash mod self.table.len());
  index? = findIndexOfKey(self.table, self.equator, startIndex, key);
  if (index?.empty?()) {
    opt Opt<K> = None<K>();
    ret opt;
  }
  node = self.table[index?.get()].get();
  opt Opt<K> = Some<K>(node);
  ret opt;
}
fn has<K, H, E>(self &HashSet<K, H, E>, key K) bool {
  not(self.get(key).empty?())
}
fn toArray<K, H, E>(self &HashSet<K, H, E>) Array<imm, K> {
  list = List<K>();
  index = 0;
  while (index < self.table.len()) {
    node? = self.table[index];
    if (not(node?.empty?())) {
      list.add(node?.get());
    }
    mut index = index + 1;
  }
  = list.toArray<imm>();
}
fn innerRemove<K, H, E>(
  table &Array<mut, Opt<K>>,
  hasher H,
  equator E,
  key K)
int {
  hash int = (hasher)(key);
  startIndex = abs(hash mod table.len());
  index? = findIndexOfKey(table, equator, startIndex, key);
  index = index?.get();
  mut table[index] = None<K>();
  ret index;
}
fn remove<K, H, E>(
  set &HashSet<K, H, E>,
  key K)
void {
  originalIndex = innerRemove(set.table, set.hasher, set.equator, key);
  mut set.size = set.size - 1;
  i! = 1;
  while (i < set.table.len()) {
    neighborIndex = (originalIndex + i) mod len(set.table);
    neighbor? = (mut set.table[neighborIndex] = None<K>());
    if (not neighbor?.empty?()) {
      neighborKey = neighbor?^.get();
      addNodeToHashSetTable(set.table, set.hasher, neighborKey);
    } else {
      drop(neighbor?);
      mut i = set.table.len(); // break
    }
    mut i = i + 1;
  }
}
fn each<K, H, E, F>(
  self &HashSet<K, H, E>,
  func F)
void {
  index! = 0;
  while (index < self.table.len()) {
    node? = self.table[index];
    if (not(node?.empty?())) {
      func(node?.get());
    }
    mut index = index + 1;
  }
}
fn min(a int, b int) int {
  = if (a <= b) { a } else { b }
}
fn max(a int, b int) int {
  = if (a >= b) { a } else { b }
}
fn panic(msg str) {
  println(msg);
  = panic();
}
fn abs(a int) {
  = if (a < 0) { a * -1 } else { a }
}
fn assert(cond bool) void {
  assert(cond, "Assertion failed!");
}
fn assert(cond bool, msg str) void {
  if (cond == false) {
    println(msg);
    panic();
  }
}
fn assertEq<T>(a T, b T) void {
  assert(a == b, "Assertion failed, not equal!");
}
fn assertEq<T>(a T, b T, msg str) void {
  assert(a == b, msg);
}
fn !=<T>(a &T, b &T) bool{
  not (a == b)
}
struct IntHasher { }
fn __call(this &IntHasher, x int) { x }
struct IntEquator { }
fn __call(this &IntEquator, a int, b int) { a == b }
fn signum(a int) int {
  = if (a < 0) { -1 }
    else if (a > 0) { 1 }
    else { 0 }
}
fn println(s str) void {
  print(s + "\n");
}
fn println(i int) void {
  print(str(i) + "\n");
}
fn println(b bool) void {
  print(str(b) + "\n");
}
fn print(i int) void {
  print(str(i));
}
fn print(b bool) void {
  print(str(b));
}
fn str(b bool) str {
  = if (b) { "true" } else { "false" }
}
fn +(i int, s str) str {
  str(i) + s
}
fn +(s str, i int) str {
  s + str(i)
}
fn +(s str, b bool) str {
  s + str(b)
}
fn set_screen_cell(
    screen &!Screen,
    game &Game,
    loc Location) {
    foreground_color = White();
    background_color = Black();
    character! = " ";
    tile? = game.get_current_level().tiles.get(loc);
    if (not tile?.empty?()) {
        tile = tile?^.get();
        if (tile.display_class == "dirt") {
            mut character = ".";
            mut foreground_color = Orange();
        } else if (tile.display_class == "grass") {
            mut character = ".";
            mut foreground_color = Green();
        } else if (tile.display_class == "wall") {
            mut character = "#";
            mut foreground_color = Gray();
        } else {
            panic("unrecognized tile display class");
        }
    } else {
        drop(tile?);
    }
    screen.set_cell(
        loc.x,
        loc.y,
        background_color,
        foreground_color,
        character);
}
fn setup(
    rand &!LCGRand,
    max_width int,
    max_height int,
    num_levels int)
Game {
    game =
        Game(
            List<Level>());
  level = make_level(max_width, max_height, &rand); // DIFFERENCE need &!
  game.levels.add(level);
    ret game;
}
fn display(
        seed int,
        maybe_screen &!Opt<Screen>,
        game &Game) {
    if (not empty?(maybe_screen)) {
        screen = maybe_screen.get();
        x! = 0;
        while (x < game.get_current_level().max_width) {
            y! = 0;
            while (y < game.get_current_level().max_height) {
                loc = Location(x, y);
                set_screen_cell(
                    &screen,
                    &game,
                    loc);
                mut y = y + 1;
            }
            mut x = x + 1;
        }
        screen.paint_screen();
    }
}
fn benchmark_rl(
    seed int,
    level_width int,
    level_height int,
    num_levels int,
    should_display bool,
    turn_delay int
) {
  rand = LCGRand(seed);
    game = setup(&rand, level_width, level_height, num_levels);
    maybe_screen =
        if (should_display) {
          z Opt<Screen> =
              Some(
                newScreen(
                game.get_current_level().max_width,
                game.get_current_level().max_height));
          = z;
        } else {
          z Opt<Screen> =
            None<Screen>();
          = z;
        };
        display(seed, &maybe_screen, &game);
}
struct LCGRand {
    seed int; // DIFFERENCE add an unsigned!
}
fn next(self &!LCGRand) int {
    a = 1103515245;
    c = 12345;
    m = 2147483647;
    mut self.seed = (a * self.seed + c) mod m;
    ret self.seed;
}
struct Game {
    levels List<Level>;
}
    fn get_current_level(self &Game) &Level {
        self.levels.get(0).get()
    }
fn get_pattern_adjacent_locations(
    center Location,
    consider_corners_adjacent bool)
List<Location> {
    result = List<Location>();
    result.add(Location(center.x - 1, center.y));
    result.add(Location(center.x, center.y + 1));
    result.add(Location(center.x, center.y - 1));
    result.add(Location(center.x + 1, center.y));
    if (consider_corners_adjacent) {
        result.add(Location(center.x - 1, center.y - 1));
        result.add(Location(center.x - 1, center.y + 1));
        result.add(Location(center.x + 1, center.y - 1));
        result.add(Location(center.x + 1, center.y + 1));
    }
    ret result;
}
fn get_pattern_locations_adjacent_to_any(
    source_locs &HashSet<Location, LocationHasher, LocationEquator>,
    include_source_locs bool,
    consider_corners_adjacent bool)
HashSet<Location, LocationHasher, LocationEquator> {
    result =
        HashSet<Location, LocationHasher, LocationEquator>(
            LocationHasher(), LocationEquator());
    each (source_locs) (original_location){
        adjacents =
            get_pattern_adjacent_locations(original_location, consider_corners_adjacent);
        if (include_source_locs) {
            adjacents.add(original_location);
        }
        each (&adjacents) (adjacent_location){
            if (include_source_locs or not source_locs.has(adjacent_location)) {
                if (not result.has(adjacent_location)) {
                    result.add(adjacent_location);
                }
            }
        }
    }
    ret result;
}
struct Level {
    max_width int;
    max_height int;
    tiles HashMap<Location, Tile, LocationHasher, LocationEquator>;
}

struct LocationHasher { }
fn __call(this &LocationHasher, loc Location) {
  hash = 0;
  mut hash = 41 * hash + loc.x;
  mut hash = 41 * hash + loc.y;
  = hash;
}
struct LocationEquator { }
fn __call(this &LocationEquator, a Location, b Location) {
  (a.x == b.x) and (a.y == b.y)
}
fn str(loc Location) {
    "(" + str(loc.x) + ", " + str(loc.y) + ")"
}
fn ==(a Location, b Location) bool {
    a.x == b.x and a.y == b.y
}
struct Location imm {
    x int;
    y int;
}
fn dist_squared(self Location, other Location) int {
    diffX = self.x - other.x;
    diffY = self.y - other.y;
    ret diffX * diffX + diffY * diffY;
}
fn next_to(
    self Location,
    other Location,
    consider_corners_adjacent bool,
    include_self bool
) bool {
    dist_squared = self.dist_squared(other);
    min_squared_distance = if (include_self) { 0 } else { 1 };
    max_squared_distance = if (consider_corners_adjacent) { 2 } else { 1 };
    ret dist_squared >= min_squared_distance and dist_squared <= max_squared_distance;
}
fn diagonal_manhattan_distance_100(&self, other Location) int {
    x_dist = (self.x - other.x).abs();
    y_dist = (self.y - other.y).abs();
    diagonal_dist = min(x_dist, y_dist); // 100 sqrt 2
    remaining_x_dist = x_dist - diagonal_dist;
    remaining_y_dist = y_dist - diagonal_dist;
    ret diagonal_dist * 144 + remaining_x_dist * 100 + remaining_y_dist * 100;
}

fn make_level(
    max_width int,
    max_height int,
    rand &!LCGRand)
Level {
    level = Level(
        max_width,
        max_height,
        HashMap<Location, Tile, LocationHasher, LocationEquator>(
            LocationHasher(), LocationEquator()));
    walkabilities = List<List<bool>>();
    x! = 0;
    while (x < max_width) {
      y! = 0;
      thisCol = List<bool>();
      while (y < max_height) {
        half_max_width = max_width / 2;
        half_max_height = max_height / 2;
        inside_ellipse =
            (x - half_max_width) * (x - half_max_width) * (half_max_height * half_max_height) +
            (y - half_max_height) * (y - half_max_height) * (half_max_width * half_max_width) <
            (half_max_width * half_max_width) * (half_max_height * half_max_height);
        walkable = rand.next() mod 2 == 0;
        thing = inside_ellipse and walkable;
        thisCol.add(thing);
        mut y = y + 1;
      }
      walkabilities.add(thisCol);
      mut x = x + 1;
    }
    mut walkabilities = smooth_level(max_width, max_height, &walkabilities);
    mut walkabilities = smooth_level(max_width, max_height, &walkabilities);
    connect_all_rooms(&rand, &walkabilities, false);
    mut x = 0;
    while (x < max_width) {
        y! = 0;
        while (y < max_height) {
            loc = Location(x, y);
            walkable = walkabilities.get(x).get().get(y).get();
            on_edge = x == 0 or y == 0 or x == max_width - 1 or y == max_height - 1;
            if (walkable and not on_edge) {
                display_class =
                  if (rand.next() mod 2 == 0) {
                    "dirt"
                  } else {
                    "grass"
                  };
                level.tiles.add(
                    loc,
                    Tile(
                        true,
                        display_class));//,
            } else {
                next_to_walkable! = false;
                neighbor_x! = max(0, x - 1);
                while (neighbor_x < min(max_width - 1, x + 1 + 1)) {
                    neighbor_y! = max(0, y - 1);
                    while (neighbor_y < min(max_height - 1, y + 1 + 1)) {
                        neighbor_walkable =
                            walkabilities.get(neighbor_x).get().get(neighbor_y).get();
                        if (neighbor_walkable) {
                            mut next_to_walkable = true;
                        }
                        mut neighbor_y = neighbor_y + 1;
                    }
                    mut neighbor_x = neighbor_x + 1;
                }
                if (next_to_walkable) {
                    level.tiles.add(
                        loc,
                        Tile(
                            false,
                            "wall"));
                }
            }
            mut y = y + 1;
        }
        mut x = x + 1;
    }
    ret level;
}
fn smooth_level(
    max_width int,
    max_height int,
    walkabilities &!List<List<bool>>)
List<List<bool>> {
    new_walkabilities = List<List<bool>>();
    x! = 0;
    while (x < max_width) {
      y! = 0;
      thisCol = List<bool>();
      while (y < max_height) {
        thisCol.add(false);
        mut y = y + 1;
      }
      new_walkabilities.add(thisCol);
      mut x = x + 1;
    }
    mut x = 0;
    while (x < max_width) {
      thisCol = List<bool>();
      y! = 0;
      while (y < max_height) {
        num_walkable_neighbors = 0;
        neighbor_x! = max(0, x - 1);
        while (neighbor_x < min(max_width - 1, x + 1 + 1)) {
          neighbor_y! = max(0, y - 1);
          while (neighbor_y < min(max_height - 1, y + 1 + 1)) {
            if (walkabilities.get(neighbor_x).get().get(neighbor_y).get()) {
                mut num_walkable_neighbors = num_walkable_neighbors + 1;
            }
            mut neighbor_y = neighbor_y + 1;
          }
          mut neighbor_x = neighbor_x + 1;
        }
        new_walkabilities.get(x).get().set(y, num_walkable_neighbors >= 5);
        mut y = y + 1;
      }
      mut x = x + 1;
    }
    ret new_walkabilities;
}
fn connect_all_rooms(
    rand &!LCGRand,
    walkabilities &!List<List<bool>>,
    consider_corners_adjacent bool) void {
    rooms = identify_rooms(&walkabilities, consider_corners_adjacent);
    connect_rooms(&rand, &rooms);
    i! = 0;
    while (i < rooms.len()) {
        new_room = rooms.get(i).get();
        each (new_room) (loc){
            walkabilities.get(loc.x).get().set(loc.y, true);
        }
        mut i = i + 1;
    }
    0;
}
fn identify_rooms(
    walkabilities &!List<List<bool>>,
    consider_corners_adjacent bool)
List<HashSet<Location, LocationHasher, LocationEquator>> {
    room_index_by_location =
        HashMap<Location, int, LocationHasher, LocationEquator>(
            LocationHasher(), LocationEquator());
    rooms =
        List<HashSet<Location, LocationHasher, LocationEquator>>();
    x! = 0;
    while (x < walkabilities.len()) {
        y! = 0;
        while (y < walkabilities.get(x).get().len()) {
            if (walkabilities.get(x).get().get(y).get()) {
                spark_location = Location(x, y);
                if (not room_index_by_location.has(spark_location)) {
                    connected_locations =
                        find_all_connected_locations(
                            &walkabilities,
                            consider_corners_adjacent,
                            spark_location);
                    new_room_index = rooms.len();
                    connected_locations_clone = connected_locations.toArray();
                    rooms.add(connected_locations); // DIFFERENCE clones
                    i! = 0;
                    while (i < connected_locations_clone.len()) {
                        connected_location = connected_locations_clone[i];
                        assert(not room_index_by_location.has(connected_location));
                        room_index_by_location.add(connected_location, new_room_index);
                        mut i = i + 1;
                    }
                }
            }
            mut y = y + 1;
        }
        mut x = x + 1;
    }
    ret rooms;
}
fn find_all_connected_locations(
    walkabilities &List<List<bool>>,
    consider_corners_adjacent bool,
    start_location Location)
HashSet<Location, LocationHasher, LocationEquator> {
    connected_with_unexplored_neighbors =
        HashSet<Location, LocationHasher, LocationEquator>(
            LocationHasher(), LocationEquator());
    connected_with_explored_neighbors =
        HashSet<Location, LocationHasher, LocationEquator>(
            LocationHasher(), LocationEquator());
    connected_with_unexplored_neighbors.add(start_location);
    while (connected_with_unexplored_neighbors.len() > 0) {
        current =
            connected_with_unexplored_neighbors.toArray()[0];
        assert(not connected_with_explored_neighbors.has(current));
        connected_with_unexplored_neighbors.remove(current);
        connected_with_explored_neighbors.add(current);
        adj_walkable_locs =
            get_adjacent_walkable_locations(walkabilities, current, consider_corners_adjacent);
        i! = 0;
        while (i < adj_walkable_locs.len()) {
            neighbor = adj_walkable_locs.get(i).get();
            if (not connected_with_explored_neighbors.has(neighbor)) {
                if (not connected_with_unexplored_neighbors.has(neighbor)) {
                    connected_with_unexplored_neighbors.add(neighbor);
                }
            }
            mut i = i + 1;
        }
    }
    ret connected_with_explored_neighbors;
}
fn connect_rooms(
    rand &!LCGRand,
    rooms &!List<HashSet<Location, LocationHasher, LocationEquator>>) {
    room_index_by_location =
        HashMap<Location, int, LocationHasher, LocationEquator>(
            LocationHasher(), LocationEquator());
    room_index! = 0;
    while (room_index < rooms.len()) {
        room = rooms.get(room_index).get();
        i! = 0;
        room_keys = room.toArray();
        while (i < room_keys.len()) {
            room_floor_loc = room_keys[i];
            room_index_by_location.add(room_floor_loc, room_index);
            mut i = i + 1;
        }
        mut room_index = room_index + 1;
    }
    regions = List<int>();
    region_by_room_index =
        HashMap<int, int, IntHasher, IntEquator>(
            IntHasher(), IntEquator());
    room_indices_by_region_num =
        HashMap<int, HashSet<int, IntHasher, IntEquator>, IntHasher, IntEquator>(
            IntHasher(), IntEquator());
    mut room_index = 0;
    while (room_index < rooms.len()) {
        region = room_index;
        region_by_room_index.add(room_index, region);
        room_indices_in_region =
            HashSet<int, IntHasher, IntEquator>(
                IntHasher(), IntEquator());
        room_indices_in_region.add(room_index);
        room_indices_by_region_num.add(region, room_indices_in_region);
        regions.add(region);
        mut room_index = room_index + 1;
    }
    outer_running! = true;
    while (outer_running) {
        distinct_regions =
            HashSet<int, IntHasher, IntEquator>(
                &region_by_room_index.values(),
                IntHasher(), IntEquator());
        if (distinct_regions.len() >= 2) {
            distinct_regions_arr = distinct_regions.toArray();
            region_a = distinct_regions_arr[0];
            region_b = distinct_regions_arr[1];
            region_a_room_index =
                get_hash_set_random_nth(&rand, &room_indices_by_region_num.get(region_a)^.get()).get();
            region_a_room = &rooms.get(region_a_room_index).get();
            region_a_location = get_hash_set_random_nth(&rand, &region_a_room).get();
            room_indices_by_region_num.get(region_b);
            room_indices_by_region_num.get(region_b)^.get();
            room_indices_by_region_num.get(region_b)^.get().len();
            region_b_room_index =
                get_hash_set_random_nth(&rand, &room_indices_by_region_num.get(region_b)^.get()).get();
            region_b_room = &rooms.get(region_b_room_index).get();
            region_b_location = get_hash_set_random_nth(&rand, &region_b_room).get();
            path! = List<Location>();
            current_location! = region_a_location;
            running! = true;
            while (running and current_location != region_b_location) {
                if (current_location.x != region_b_location.x) {
                    mut current_location =
                        Location(
                            current_location.x + (region_b_location.x - current_location.x).signum(),
                            current_location.y);
                } else if (current_location.y != region_b_location.y) {
                    mut current_location =
                        Location(
                            current_location.x,
                            current_location.y + (region_b_location.y - current_location.y).signum());
                } else {
                    panic("wat");
                }
                if (not room_index_by_location.has(current_location)) {
                    path.add(current_location);
                } else {
                    current_room_index = room_index_by_location.get(current_location).get();
                    current_region = region_by_room_index.get(current_room_index).get();
                    if (current_region == region_a) {
                        mut path = List<Location>();
                    } else if (current_region != region_a) {
                        mut running = false;
                    }
                }
            }
            combined_region = regions.len();
            regions.add(combined_region);
            new_room_index = rooms.len();
            rooms.add(
                HashSet<Location, LocationHasher, LocationEquator>(
                    &path.toArray<mut>(), LocationHasher(), LocationEquator()));
            each (&path) (path_location){
                room_index_by_location.add(path_location, new_room_index);
            }
            region_by_room_index.add(new_room_index, combined_region);
            path_adjacent_locations =
                get_pattern_locations_adjacent_to_any(
                    &HashSet<Location, LocationHasher, LocationEquator>(
                        &path.toArray<mut>(), LocationHasher(), LocationEquator()),
                    true,
                    false);
            path_adjacent_regions =
                HashSet<int, IntHasher, IntEquator>(
                    IntHasher(), IntEquator());
            each (&path_adjacent_locations) (path_adjacent_location){
                if (&room_index_by_location has path_adjacent_location) {
                    room_index = room_index_by_location.get(path_adjacent_location).get();
                    region = region_by_room_index.get(room_index).get();
                    if (not path_adjacent_regions.has(region)) {
                        path_adjacent_regions.add(region);
                    }
                }
            }
            room_indices_in_combined_region =
                HashSet<int, IntHasher, IntEquator>(
                    IntHasher(), IntEquator());
            room_indices_in_combined_region.add(new_room_index);
            each (&path_adjacent_regions) (path_adjacent_region){
                if (path_adjacent_region != combined_region) {
                    each (room_indices_by_region_num.get(path_adjacent_region)^.get()) (path_adjacent_room_index){
                        region_by_room_index.update(path_adjacent_room_index, combined_region);
                        room_indices_in_combined_region.add(path_adjacent_room_index);
                    }
                    room_indices_by_region_num.remove(path_adjacent_region);
                }
            }
            room_indices_by_region_num.add(combined_region, room_indices_in_combined_region);
        } else {
            mut outer_running = false;
        }
    }
    0;
}
fn get_hash_set_random_nth<T, H, E>(
    rand &!LCGRand,
    set &HashSet<T, H, E>)
Opt<T> {
    if (set.empty?()) {
        result Opt<T> = None<T>();
        ret result;
    }
    keys = set.toArray();
    ret Some(keys[rand.next() mod keys.len()]);
}
fn get_adjacent_locations(
    width int,
    height int,
    center Location,
    consider_corners_adjacent bool)
List<Location> {
    result = List<Location>();
    pals = get_pattern_adjacent_locations(center, consider_corners_adjacent);
    i! = 0;
    while (i < pals.len()) {
        adjacent = pals.get(i).get();
        if (adjacent.x >= 0 and adjacent.y >= 0 and adjacent.x < width and adjacent.y < height) {
            result.add(adjacent);
        }
        mut i = i + 1;
    }
    ret result;
}
fn get_adjacent_walkable_locations(
    walkabilities &List<List<bool>>,
    center Location,
    consider_corners_adjacent bool)
List<Location> {
    result = List<Location>();
    adjacents =
        get_adjacent_locations(
            walkabilities.len(),
            walkabilities.get(0).get().len(),
            center,
            consider_corners_adjacent);
    i! = 0;
    while (i < adjacents.len()) {
        neighbor = adjacents.get(i).get();
        if (walkabilities.get(neighbor.x).get().get(neighbor.y).get()) {
            result.add(neighbor);
        }
        mut i = i + 1;
    }
    ret result;
}
struct ScreenColor imm { i int; }
fn Black() { ScreenColor(0) }
fn DarkGray() { ScreenColor(1) }
fn Turquoise() { ScreenColor(2) }
fn Red() { ScreenColor(3) }
fn LightGray() { ScreenColor(4) }
fn Orange() { ScreenColor(5) }
fn Yellow() { ScreenColor(6) }
fn OrangeYellow() { ScreenColor(7) }
fn Green() { ScreenColor(8) }
fn White() { ScreenColor(9) }
fn Gray() { ScreenColor(10) }
fn ==(a ScreenColor, b ScreenColor) { a.i == b.i }
struct ScreenCell {
    fg_color ScreenColor;
    bg_color ScreenColor;
    character str;
    dirty bool;
}
struct Screen {
    width int;
    height int;
    cells List<List<ScreenCell>>;
    status_line str;
}
struct StrBox {
    i str;
    b bool;
}
fn newScreen(width int, height int) Screen {
    println("\u001b[1;1H\u001b[2J");
    cells = List<List<ScreenCell>>();
    x! = 0;
    while (x < width) {
        q = List<ScreenCell>();
        y! = 0;
        while (y < height) {
            q.add(
                ScreenCell(
                    White(),
                    Black(),
                    " ",
                    true // All cells start as dirty, so we can display them all now
                ));
            mut y = y + 1;
        }
        cells.add(q);
        mut x = x + 1;
    }
    ret Screen(
        width,
        height,
        cells,
        "");
}
fn set_cell(
    self &!Screen,
    x int,
    y int,
    bg_color ScreenColor,
    fg_color ScreenColor,
    character str
) {
    cell = &self.cells.get(x).get().get(y).get();
    if (bg_color != cell.bg_color) {
        mut cell.bg_color = bg_color;
        mut cell.dirty = true;
    }
    if (fg_color != cell.fg_color) {
        mut cell.fg_color = fg_color;
        mut cell.dirty = true;
    }
    if (character != cell.character) {
        mut cell.character = character;
        mut cell.dirty = true;
    }
}
fn paint_screen(self &Screen) {
    x! = 0;
    while (x < self.width) {
        y! = 0;
        while (y < self.height) {
            if (self.cells.get(x).get().get(y).get().dirty) {
                self.paint_cell(x, y);
            }
            mut y = y + 1;
        }
        mut x = x + 1;
    }
    print("\u001b[" + self.height + ";" + 0 + "H");
    println(self.status_line);
}
fn paint_cell(&self, x int, y int) {
    cell = &self.cells.get(x).get().get(y).get();
    (fg_red, fg_green, fg_blue) =
        if (cell.bg_color == DarkGray()) { [40, 40, 40] }
        else if (cell.bg_color == Orange()) { [255, 96, 0] }
        else if (cell.bg_color == Red()) { [255, 0, 0] }
        else if (cell.bg_color == Black()) { [0, 0, 0] }
        else { panic("Unimplemented") };
    (bg_red, bg_green, bg_blue) =
        if (cell.fg_color == Red()) { [255, 0, 0] }
        else if (cell.fg_color == Turquoise()) { [0, 128, 255] }
        else if (cell.fg_color == Orange()) { [255, 96, 0] }
        else if (cell.fg_color == Green()) { [0, 196, 0] }
        else if (cell.fg_color == Yellow()) { [255, 255, 0] }
        else if (cell.fg_color == OrangeYellow()) { [255, 186, 0] }
        else if (cell.fg_color == LightGray()) { [224, 224, 224] }
        else if (cell.fg_color == Gray()) { [150, 150, 150] }
        else if (cell.fg_color == White()) { [255, 255, 255] }
        else { panic("Unimplemented") };
    character = &cell.character;
    print("\u001b[" + y + ";" + x + "H");
    print(
        "\u001b[" +
        "38;2;" + bg_red + ";" + bg_green + ";" + bg_blue + ";" +
        "48;2;" + fg_red + ";" + fg_green + ";" + fg_red + "m" +
        character + "\u001b[0m");
}
struct Tile {
    walkable bool;
    display_class str;
}
fn main() {
  seed = 44;// DIFFERENCE
  benchmark_rl(
    seed,
    30,
    20,
    10,
    true,
    100);
  = 0;
}
