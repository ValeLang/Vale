
struct HashSet<K, H, E> {
  hasher H;
  equator E;
  table! Array<mut, Opt<K>>;
  size! int;
}

fn HashSet<K, H, E>(hasher H, equator E) HashSet<K, H, E> {
  HashSet<K, H, E>(hasher, equator, 0)
}

fn HashSet<K, H, E>(hasher H, equator E, capacity int) HashSet<K, H, E> {
  HashSet<K>(
      hasher,
      equator,
      MakeArray(
        capacity,
        &!IFunction1<mut, int, Opt<K>>((index){
          opt Opt<K> = None<K>();
          = opt;
        })),
      0)
}

fn HashSet<K, H, E, M, N>(
    valuesKSA &[<M> N * K],
    hasher H,
    equator E)
HashSet<K, H, E> {
  this = HashSet<K, H, E>(hasher, equator, 0);
  each (&!valuesKSA) (v){
    if (not this.has(v)) {
      this!.add(v);
    }
  }
  ret this;
}

fn HashSet<K, H, E, M>(
    valuesArray &Array<M, K>,
    hasher H,
    equator E)
HashSet<K, H, E> {
  this = HashSet<K, H, E>(hasher, equator, 0);
  each (valuesArray) (v){
    if (not this.has(v)) {
      this!.add(v);
    }
  }
  ret this;
}

fn len<K, H, E>(sett &HashSet<K, H, E>) int { sett.size }

fn isEmpty<K, H, E>(sett &HashSet<K, H, E>) bool { sett.size == 0 }

fn add<K, H, E>(sett &!HashSet<K, H, E>, key K) void {
  if (sett.has(key)) {
    panic("HashSet already has given key!");
  }
  if ((sett.size + 1) * 2 >= sett.table.len()) {
    newSize =
        if (sett.table.len() == 0) { 2 }
        else { sett.table.len() * 2 };
    newTable =
        MakeArray(
            newSize,
            &!IFunction1<mut, int, Opt<K>>((index){
              opt Opt<K> = None<K>();
              = opt;
            }));
    i! = 0;
    while (i < sett.table.len()) {
      if (sett.table[i].isEmpty()) {
        // do nothing
      } else {
        node? = (set sett.table[i] = None<K>());
        node = get(node?);
        addNodeToHashSetTable(&!newTable, sett.hasher, node);
      }
      set i = i + 1;
    }
    set sett.table = newTable;
  }

  addNodeToHashSetTable(&!sett.table, sett.hasher, key);
  set sett.size = sett.size + 1;
}

fn addNodeToHashSetTable<K, H>(table &!Array<mut, Opt<K>>, hasher H, key K) {
  hash int = (&hasher)(key);
  startIndex = abs(hash mod table.len());
  index = findEmptyIndexInHashSetForKey(&table, startIndex, key);

  opt Opt<K> = Some(key);
  set table[index] = opt;
}

fn findEmptyIndexInHashSetForKey<K>(table &Array<mut, Opt<K>>, startIndex int, key K) int {
  i! = 0;
  while (i < table.len()) {
    index = (startIndex + i) mod table.len();
    something = table[index];
    if (something.isEmpty()) {
      ret index;
    }
    // continue to next node
    set i = i + 1;
  }
  = panic("findEmptyIndexInHashSetForKey went past end of table!");
}

fn findIndexOfKey<K, E>(table &Array<mut, Opt<K>>, equator E, startIndex int, key K) Opt<int> {
  i! = 0;
  while (i < table.len()) {
    index = (startIndex + i) mod table.len();
    something = table[index];
    if (something.isEmpty()) {
      ret None<int>();
    }
    node = something.get();
    if ((equator)(node, key)) {
      ret Some<int>(index);
    }
    // continue to next node
    set i = i + 1;
  }
  = panic("findIndexOfKey went past end of table! len " + str(table.len()) + " and i " + str(i));
}

fn get<K, H, E>(self &HashSet<K, H, E>, key K) Opt<K> {
  if (self.table.len() == 0) {
    ret None<K>();
  }
  hash int = (&self.hasher)(key);
  startIndex = abs(hash mod self.table.len());
  index? = findIndexOfKey(&self.table, self.equator, startIndex, key);
  if (index?.isEmpty()) {
    opt Opt<K> = None<K>();
    ret opt;
  }
  node = self.table[index?.get()].get();
  opt Opt<K> = Some<K>(node);
  ret opt;
}

fn has<K, H, E>(self &HashSet<K, H, E>, key K) bool {
  not(self.get(key).isEmpty())
}

fn toArray<K, H, E>(self &HashSet<K, H, E>) Array<imm, K> {
  list = List<K>();
  index! = 0;
  while (index < self.table.len()) {
    node? = self.table[index];
    if (not(node?.isEmpty())) {
      list!.add(node?.get());
    }
    set index = index + 1;
  }
  = list.toImmArray();
}

fn innerRemove<K, H, E>(
  table &!Array<mut, Opt<K>>,
  hasher H,
  equator E,
  key K)
int {
  hash int = (&hasher)(key);
  startIndex = abs(hash mod table.len());
  index? = findIndexOfKey(&table, &equator, startIndex, key);
  index = index?.get();
  set table[index] = None<K>();
  ret index;
}

fn remove<K, H, E>(
  sett &!HashSet<K, H, E>,
  key K)
void {
  originalIndex = innerRemove(&!sett.table, sett.hasher, sett.equator, key);
  set sett.size = sett.size - 1;

  i! = 1;
  while (i < sett.table.len()) {
    neighborIndex = (originalIndex + i) mod len(&sett.table);
    neighbor? = (set sett.table[neighborIndex] = None<K>());
    if (not neighbor?.isEmpty()) {
      neighborKey = neighbor?^.get();
      addNodeToHashSetTable(&!sett.table, sett.hasher, neighborKey);
    } else {
      drop(neighbor?);
      set i = sett.table.len(); // break
    }
    set i = i + 1;
  }
}

fn each<K, H, E, F>(
  self &HashSet<K, H, E>,
  func F)
void {
  index! = 0;
  while (index < self.table.len()) {
    node? = self.table[index];
    if (not(node?.isEmpty())) {
      func(node?.get());
    }
    set index = index + 1;
  }
}

fn each<K, H, E, F>(
  self &!HashSet<K, H, E>,
  func F)
void {
  index! = 0;
  while (index < self.table.len()) {
    node? = self.table[index];
    if (not(node?.isEmpty())) {
      func(node?.get());
    }
    set index = index + 1;
  }
}
