interface Opt<T> rules(T Ref) { }
struct Some<T> rules(T Ref) { value T; }
impl<T> Some<T> for Opt<T>;
struct None<T> rules(T Ref) { }
impl<T> None<T> for Opt<T>;

abstract fn empty?<T>(virtual opt &Opt<T>) bool;
fn empty?<T>(opt &None<T> impl Opt<T>) bool { true }
fn empty?<T>(opt &Some<T> impl Opt<T>) bool { false }

abstract fn get<T>(virtual opt Opt<T>) T;
fn get<T>(opt None<T> impl Opt<T>) T { panic() }
fn get<T>(opt Some<T> impl Opt<T>) T {
  Some<T>(value) = opt;
  = value;
}

abstract fn get<T>(virtual opt &Opt<T>) &T;
fn get<T>(opt &None<T> impl Opt<T>) &T { panic() }
fn get<T>(opt &Some<T> impl Opt<T>) &T { opt.value }

abstract fn getOr<T>(virtual opt &Opt<T>, default T) T;
fn getOr<T>(opt &None<T> impl Opt<T>, default T) T {
  default
}
fn getOr<T>(opt &Some<T> impl Opt<T>, default T) T {
  opt.value
}

abstract fn map<T, R>(virtual opt &Opt<T>, func &IFunction1<mut, &T, R>) Opt<R>;
fn map<T, R>(opt &None<T> impl Opt<T>, func &IFunction1<mut, &T, R>) Opt<R> {
  None<R>()
}
fn map<T, R>(opt &Some<T> impl Opt<T>, func &IFunction1<mut, &T, R>) Opt<R> {
  Some<R>(func(opt.value))
}

abstract fn getSize<T>(virtual opt &Opt<T>) *int;
fn getSize<T>(opt &None<T> impl Opt<T>) *int { 0 }
fn getSize<T>(opt &Some<T> impl Opt<T>) *int { 1 }

struct List<E> rules(E Ref) {
  array Array<mut, Opt<E>>;
  size int;
}
fn List<E>() rules(E Ref) {
  List<E>(Array<mut, Opt<E>>(0, &IFunction1<mut, int, Opt<E>>((index){ panic()})), 0)
}
fn len<E>(list &List<E>) { list.size }
fn add<E>(list &List<E>, newElement E) {
  if (list.size == list.len()) {
    newLen = if (len(list) == 0) { 1 } else { len(list) * 2 };
    newArray =
        Array<mut, Opt<E>>(newLen, &IFunction1<mut, int, Opt<E>>((index){
          = if (index < len(list)) {
              = (mut list.array[index] = None<E>());
            } else {
              result Opt<E> = None<E>();
              = result;
            }
        }));
    mut list.array = newArray;
  }
  mut list.array[list.size] = Some<E>(newElement);
  mut list.size = list.size + 1;
}
// todo make that return a &E
fn get<E>(list &List<E>, index int) &Opt<E> {
  a = list.array;
  = a[index];
}
fn set<E>(list &List<E>, index int, value E) void {
  mut list.array[index] = Some(value);
}
fn toArray<M, E>(list &List<E>) Array<M, E> rules(M Mutability) {
  Array<M, E>(list.len(), &IFunction1<mut, int, E>((i){ list.get(i).get()}))
}
fn toList<E>(arr &Array<_, E>) List<E> {
  list = List<E>();
  arr each (elem){
    list.add(elem);
  };
  = list;
}


fn panic(msg str) {
  println(msg);
  = panic();
}

fn abs(a int) {
  = if (a < 0) { a * -1 } else { a }
}

struct HashNode<K, V> {
  key K;
  value V;
}

struct HashMap<K, V, H, E> {
  hasher H;
  equator E;
  table Array<mut, Opt<HashNode<K, V>>>;
  size int;
}

fn HashMap<K, V, H, E>(hasher H, equator E) HashMap<K, V, H, E> {
  HashMap<K, V, H, E>(hasher, equator, 0)
}

fn HashMap<K, V, H, E>(hasher H, equator E, capacity int) HashMap<K, V, H, E> {
  HashMap<K, V>(
      hasher,
      equator,
      Array<mut, Opt<HashNode<K, V>>>(
        capacity,
        &IFunction1<mut, int, Opt<HashNode<K, V>>>((index){
          opt Opt<HashNode<K, V>> = None<HashNode<K, V>>();
          = opt;
        })),
      0)
}

fn add<K, V, H, E>(map &HashMap<K, V, H, E>, key K, value V) void {
  if (map.has(key)) {
    panic("Map already has given key!");
  }
  if ((map.size + 1) * 2 >= map.table.len()) {
    newSize =
        if (map.table.len() == 0) { 2 }
        else { map.table.len() * 2 };
    newTable =
        Array<mut, Opt<HashNode<K, V>>>(
            newSize,
            &IFunction1<mut, int, Opt<HashNode<K, V>>>((index){
              opt Opt<HashNode<K, V>> = None<HashNode<K, V>>();
              = opt;
            }));
    i = 0;
    while (i < map.table.len()) {
      if (map.table[i].empty?()) {
        // do nothing
      } else {
        node? = (mut map.table[i] = None<HashNode<K, V>>());
        node = get(node?);
        addNodeToTable(&newTable, map.hasher, node);
      }
      mut i = i + 1;
    }
    mut map.table = newTable;
  }

  addNodeToTable(map.table, map.hasher, HashNode<K, V>(key, value));
  mut map.size = map.size + 1;
}

fn addNodeToTable<K, V, H>(table &Array<mut, Opt<HashNode<K, V>>>, hasher H, node HashNode<K, V>) {
  hash = (hasher)(node.key);
  startIndex = abs(hash mod table.len());
  index = findEmptyIndexForKey(table, startIndex, node.key);

  opt Opt<HashNode<K, V>> = Some(node);
  mut table[index] = opt;
}

fn findEmptyIndexForKey<K, V>(table &Array<mut, Opt<HashNode<K, V>>>, startIndex int, key K) int {
  i = 0;
  while (i < table.len()) {
    index = (startIndex + i) mod table.len();
    something = table[index];
    if (something.empty?()) {
      ret index;
    }
    // continue to next node
    mut i = i + 1;
  }
  = panic("findEmptyIndexForKey went past end of table!");
}

fn findIndexOfKey<K, V, E>(table &Array<mut, Opt<HashNode<K, V>>>, equator E, startIndex int, key K) Opt<int> {
  i = 0;
  while (i < table.len()) {
    index = (startIndex + i) mod table.len();
    something = table[index];
    if (something.empty?()) {
      ret None<int>();
    }
    node = something.get();
    if ((equator)(node.key, key)) {
      ret Some<int>(index);
    }
    // continue to next node
    mut i = i + 1;
  }
  = panic("findIndexOfKey went past end of table! len " + str(table.len()) + " and i " + str(i));
}

fn get<K, V, H, E>(self &HashMap<K, V, H, E>, key K) Opt<&V> {
  if (self.table.len() == 0) {
    ret None<&V>();
  }
  hash = (self.hasher)(key);
  startIndex = abs(hash mod self.table.len());
  index? = findIndexOfKey(self.table, self.equator, startIndex, key);
  if (index?.empty?()) {
    opt Opt<&V> = None<&V>();
    ret opt;
  }
  node = self.table[index?.get()].get();
  opt Opt<&V> = Some<&V>(node.value);
  ret opt;
}

fn has<K, V, H, E>(self &HashMap<K, V, H, E>, key K) bool {
  not(self.get(key).empty?())
}

fn keys<K, V, H, E>(self &HashMap<K, V, H, E>) Array<imm, K> {
  list = List<K>();
  index = 0;
  while (index < self.table.len()) {
    node? = self.table[index];
    if (not(node?.empty?())) {
      list.add(node?.get().key);
    }
    mut index = index + 1;
  }
  = list.toArray<imm>();
}



fn toArray<M, N, E, SM>(seq &[<SM> N * E]) rules(M Mutability) {
  Array<M, E>(N, &IFunction1<SM, int, E>((i){ seq[i]}))
}

//fn each<N, E, F, M>(seq &[<M> N * E], func F) void {
//  Array<mut, int>(N, &IFunction1<mut, int, int>((i){ func(seq[i]); = 0; }));
//}

//fn map<M>(seq &[<_> N * E], func F) rules(M Mutability) {
//  Array<M>(N, (i){ func(seq[i]) })
//}

//fn each<E, F>(arr &Array<_, E>, func F) void {
//  Array<mut, int>(arr.len(), &IFunction1<mut, int, void>((i){ func(arr[i]); = 0; }));
//}

//fn map<M>(arr &Array<_, E>, func F) rules(M Mutability) {
//  Array<M>(arr.len(), (i){ func(arr[i]) })
//}

fn has<E, F>(arr &Array<_, E>, elem E, equator F) bool {
  i = 0;
  while (i < arr.len()) {
    if ((equator)(arr[i], elem)) {
      ret true;
    }
    mut i = i + 1;
  }
  = false;
}

fn has<E>(arr &Array<_, E>, elem E) bool {
  has(arr, elem, ==)
}

fn has<E, F>(seq &[<_> _ * E], elem E, equator F) bool {
  i = 0;
  while (i < seq.len()) {
    if ((equator)(seq[i], elem)) {
      ret true;
    }
    mut i = i + 1;
  }
  = false;
}

fn has<E>(seq &[<_> _ * E], elem E) bool {
  has(seq, elem, ==)
}

fn Arr<M, F>(n int, generator &F) Array<M, T>
rules(M Mutability, T Ref, Prot("__call", (&F, int), T))
{
  Array<M>(n, &IFunction1<mut, int, T>(generator))
}

fn each<M, T, F>(arr &Array<M, T>, func F) void {
  i! = 0;
  l = len(&arr);
  while (i < l) {
    func(arr[i]);
    mut i = i + 1;
  }
}

fn indices<>(arr &Array<_, _>) Array<imm, int> {
  Arr<imm>(len(arr), {_})
}

fn eachI<F>(arr &Array<_, _>, func F) void {
  i! = 0;
  l = len(&arr);
  while (i < l) {
    func(i, arr[i]);
    mut i = i + 1;
  }
}



struct Vec2 imm {
  x float;
  y float;
}

struct Vec3 imm {
  x float;
  y float;
  z float;
}

struct Location imm {
  groupX int;
  groupY int;
  indexInGroup int;
}

struct Pattern imm {
  name str;
  cornersByShapeIndex Array<imm, Array<imm, Vec2>>;
  patternTiles Array<imm, PatternTile>;
  xOffset Vec2;
  yOffset Vec2;
}

struct PatternTile imm {
  shapeIndex int;
  rotateRadians float;
  translate Vec2;
  sideAdjacenciesBySideIndex Array<imm, PatternSideAdjacency>;
  cornerAdjacenciesByCornerIndex Array<imm, Array<imm, PatternCornerAdjacency>>;
}

struct PatternSideAdjacency imm {
  groupRelativeX int;
  groupRelativeY int;
  tileIndex int;
  sideIndex int;
}

struct PatternCornerAdjacency imm {
  groupRelativeX int;
  groupRelativeY int;
  tileIndex int;
  cornerIndex int;
}


struct TerrainTile {
  elevation int;
  walkable bool;
  classId str;
}

struct LocationHasher { }
fn __call(this &LocationHasher, loc Location) {
  hash! = 0;
  mut hash = 41 * hash + loc.groupX;
  mut hash = 41 * hash + loc.groupY;
  mut hash = 41 * hash + loc.indexInGroup;
  = hash;
}

struct LocationEquator { }
fn __call(this &LocationEquator, a Location, b Location) {
  (a.groupX == b.groupX) and (a.groupY == b.groupY) and (a.indexInGroup == b.indexInGroup)
}

struct Terrain {
  pattern Pattern;
  elevationStepHeight float;
  tiles HashMap<Location, TerrainTile, LocationHasher, LocationEquator>;
}

fn makeBoard() Array<mut, Array<mut, str>> {
  ret
    Arr<mut>(10, (row){
      Arr<mut>(10, (col){
        = if (row == 0) { "#" }
          else if (col == 0) { "#" }
          else if (row == 9) { "#" }
          else if (col == 9) { "#" }
          else { "." }
      })
    });
}

fn display(board &Array<mut, Array<mut, str>>, playerRow int, playerCol int) {
  toPrint! = "";
  eachI &board (rowI, row){
    eachI &row (cellI, cell){
      if (and(rowI == playerRow, cellI == playerCol)) {
        mut toPrint = toPrint + "@";
      } else {
        mut toPrint = toPrint + cell;
      }
    }
    mut toPrint = toPrint + "\n";
  }
  print(toPrint);
}

fn inputKey() int {
  key! = 0;
  running! = true;
  while (running) {
    mut key = __getch();
    println(key);
    if (key == 81) {
      mut running = false;
    } else if (key == 119) {
      mut running = false;
    } else if (key == 115) {
      mut running = false;
    } else if (key == 97) {
      mut running = false;
    } else if (key == 100) {
      mut running = false;
    } else if (key == 10) {
      // Enter key, do nothing
    }
    // Continue
  }
  ret key;
}

struct IntHasher { }
fn __call(this &IntHasher, x int) { x }

struct IntEquator { }
fn __call(this &IntEquator, a int, b int) { a == b }

struct Goblin {
  row! int;
  col! int;
}

fn main() int {
  board = makeBoard();

  playerRow! = 4;
  playerCol! = 3;

  // goblins = HashMap<int, Goblin, IntHasher, IntEquator>(IntHasher(), IntEquator());
  // goblins.add(17, Goblin(2, 3));
  // goblins.add(17, Goblin(7, 4));
  // goblins.add(17, Goblin(8, 3));

  running! = true;
  while (running) {
    display(&board, playerRow, playerCol);

    key = inputKey();
    newPlayerRow! = playerRow;
    newPlayerCol! = playerCol;
    if (key == 81) {
      mut running = false;
    } else if (key == 119) {
      mut newPlayerRow = newPlayerRow - 1;
    } else if (key == 115) {
      mut newPlayerRow = newPlayerRow + 1;
    } else if (key == 97) {
      mut newPlayerCol = newPlayerCol - 1;
    } else if (key == 100) {
      mut newPlayerCol = newPlayerCol + 1;
    }
    if (board[newPlayerRow][newPlayerCol] == ".") {
      mut playerRow = newPlayerRow;
      mut playerCol = newPlayerCol;
    }
  }
  = 0;
}
