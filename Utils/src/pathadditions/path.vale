
interface FileError { }
struct FileNotFoundError {
  path Path;
}
impl FileError for FileNotFoundError;

fn RemoveDirAll(path &Path) Result<void, FileError> {
  is_symlink_result = path.IsSymLink();
  if (is_symlink_result.is_err()) {
    ret Err<void, FileError>((is_symlink_result).expect_err());
  }
  is_symlink = is_symlink_result.expect();
  = if (is_symlink) {
      RemoveFile(path)
    } else {
      RemoveDirAllRecursive(path)
    }
}

fn RemoveDirAllRecursive(path &Path) Result<void, FileError> {
  read_dir_result = ListDir(path);
  children =
    if (read_dir_result.is_ok()) {
      read_dir_result.expect()
    } else {
      ret Err<void, FileError>((read_dir_result).expect_err());
    };

  i = 0;
  while (i < children.len()) {
    child = children.get(i);
    is_directory_result = IsDirectory(child);
    if (is_directory_result.is_err()) {
      ret Err<void, FileError>((is_directory_result).expect_err());
    }
    is_dir = is_directory_result.expect();

    if (is_dir) {
      remove_dir_all_recursive_result = RemoveDirAllRecursive(child);
      if (remove_dir_all_recursive_result.is_err()) {
        ret Err<void, FileError>((remove_dir_all_recursive_result).expect_err());
      }
      remove_dir_all_recursive_result.expect();
      // continue
    } else {
      remove_file_result = RemoveFile(child);
      if (remove_file_result.is_err()) {
        ret Err<void, FileError>((remove_file_result).expect_err());
      }
      remove_file_result.expect();
      // continue
    }
    set i = i + 1;
  }

  ret RemoveDir(path);
}

fn ListDir(path &Path) Result<List<Path>, FileError> {
  Ok<List<Path>, FileError>(iterdir(path))
}

fn ExternErrorCodeToError(error_code int, path &Path) FileError {
  = if (error_code == 0) {
      panic("ExternErrorCodeToError Extern error: bad argument")
    } else if (error_code == 1) {
      FileNotFoundError(path.clone())
    } else {
      panic("RemoveDir: unknown Extern error code {error_code}")
    }
}

fn RemoveDir(path &Path) Result<void, FileError> {
  error_code = RemoveDirExtern(path.str());
  = if (error_code == 0) {
      Ok<void, FileError>(void())
    } else {
      Err<void, FileError>(ExternErrorCodeToError(error_code, path))
    }
}

fn RemoveDirExtern(path str) int extern;

fn RemoveFile(path &Path) Result<void, FileError> {
  error_code = RemoveFileExtern(path.str());
  = if (error_code == 0) {
      Ok<void, FileError>(void())
    } else {
      Err<void, FileError>(ExternErrorCodeToError(error_code, path))
    }
}

fn RemoveFileExtern(path str) int extern;

fn IsSymLink(path &Path) Result<bool, FileError> {
  Ok<bool, FileError>(IsSymLinkExtern(path.str()))
}

fn IsSymLinkExtern(path str) bool extern;

fn IsDirectory(path &Path) Result<bool, FileError> {
  Ok<bool, FileError>(is_dir(path))
}

fn CreateDir(path &Path, allow_already_existing bool) Result<void, FileError> {
  = if (CreateDirExtern(path.str(), if (allow_already_existing) { 1 } else { 0 })) {
      Ok<void, FileError>(void())
    } else {
      panic("Error in CreateDir")
    }
}

// change to bool in next version, has fix
fn CreateDirExtern(path str, allow_already_existing int) bool extern;

fn CreateDirAll(path &Path, allow_already_existing bool) Result<void, FileError> {
  if (path.segments.len() == 0) {
    ret Err<void, FileError>(FileNotFoundError(path.clone()));
  }
  if (not path.exists()) {
    // Recurse
    recurse_result = CreateDirAll(&path.parent(), allow_already_existing);
    if (recurse_result.is_err()) {
      ret recurse_result;
    }
    recurse_result.expect();

    create_dir_result = path.CreateDir(allow_already_existing);
    if (create_dir_result.is_err()) {
      ret create_dir_result;
    }
    create_dir_result.expect();
  }
  ret Ok<void, FileError>(void());
}

fn Rename(path &Path, destination &Path) Result<void, FileError> {
  error_code = RenameExtern(path.str(), destination.str());
  = if (error_code == 0) {
      Ok<void, FileError>(void())
    } else {
      Err<void, FileError>(ExternErrorCodeToError(error_code, path))
    }
}

fn RenameExtern(path str, destination str) int extern;
