interface Opt<T> rules(T Ref) { }
struct Some<T> rules(T Ref) { value T; }
impl<T> Some<T> for Opt<T>;
struct None<T> rules(T Ref) { }
impl<T> None<T> for Opt<T>;

abstract fn empty?<T>(virtual opt &Opt<T>) Bool;
fn empty?<T>(opt &None<T> impl Opt<T>) Bool { true }
fn empty?<T>(opt &Some<T> impl Opt<T>) Bool { false }

abstract fn get<T>(virtual opt Opt<T>) T;
fn get<T>(opt None<T> impl Opt<T>) T { panic() }
fn get<T>(opt Some<T> impl Opt<T>) T {
  Some<T>(value) = opt;
  = value;
}

abstract fn get<T>(virtual opt &Opt<T>) &T;
fn get<T>(opt &None<T> impl Opt<T>) &T { panic() }
fn get<T>(opt &Some<T> impl Opt<T>) &T { opt.value }

abstract fn getOr<T>(virtual opt &Opt<T>, default T) T;
fn getOr<T>(opt &None<T> impl Opt<T>, default T) T {
  default
}
fn getOr<T>(opt &Some<T> impl Opt<T>, default T) T {
  opt.value
}

abstract fn map<T, R>(virtual opt &Opt<T>, func &IFunction1<mut, &T, R>) Opt<R>;
fn map<T, R>(opt &None<T> impl Opt<T>, func &IFunction1<mut, &T, R>) Opt<R> {
  None<R>()
}
fn map<T, R>(opt &Some<T> impl Opt<T>, func &IFunction1<mut, &T, R>) Opt<R> {
  Some<R>(func(opt.value))
}

abstract fn getSize<T>(virtual opt &Opt<T>) *Int;
fn getSize<T>(opt &None<T> impl Opt<T>) *Int { 0 }
fn getSize<T>(opt &Some<T> impl Opt<T>) *Int { 1 }

struct List<E> rules(E Ref) {
  array Array<mut, Opt<E>>;
  size Int;
}
fn List<E>() rules(E Ref) {
  List<E>(Array<mut, Opt<E>>(0, &IFunction1<mut, Int, Opt<E>>((index){ panic()})), 0)
}
fn len<E>(list &List<E>) { list.size }
fn add<E>(list &List<E>, newElement E) {
  if (list.size == list.len()) {
    newLen = if (len(list) == 0) { 1 } else { len(list) * 2 };
    newArray =
        Array<mut, Opt<E>>(newLen, &IFunction1<mut, Int, Opt<E>>((index){
          = if (index < len(list)) {
              = (mut list.array[index] = None<E>());
            } else {
              result Opt<E> = None<E>();
              = result;
            }
        }));
    mut list.array = newArray;
  }
  mut list.array[list.size] = Some<E>(newElement);
  mut list.size = list.size + 1;
}
// todo make that return a &E
fn get<E>(list &List<E>, index Int) &Opt<E> {
  a = list.array;
  = a[index];
}
fn set<E>(list &List<E>, index Int, value E) Void {
  mut list.array[index] = Some(value);
}
fn toArray<M, E>(list &List<E>) Array<M, E> rules(M Mutability) {
  Array<M, E>(list.len(), &IFunction1<mut, Int, E>((i){ list.get(i).get()}))
}
fn toList<E>(arr &Array<_, E>) List<E> {
  list = List<E>();
  arr each (elem){
    list.add(elem);
  };
  = list;
}


fn panic(msg Str) {
  println(msg);
  = panic();
}

fn abs(a Int) {
  = if (a < 0) { a * -1 } else { a }
}

struct HashNode<K, V> {
  key K;
  value V;
}

struct HashMap<K, V, H, E> {
  hasher H;
  equator E;
  table Array<mut, Opt<HashNode<K, V>>>;
  size Int;
}

fn HashMap<K, V, H, E>(hasher H, equator E) HashMap<K, V, H, E> {
  HashMap<K, V, H, E>(hasher, equator, 0)
}

fn HashMap<K, V, H, E>(hasher H, equator E, capacity Int) HashMap<K, V, H, E> {
  HashMap<K, V>(
      hasher,
      equator,
      Array<mut, Opt<HashNode<K, V>>>(
        capacity,
        &IFunction1<mut, Int, Opt<HashNode<K, V>>>((index){
          opt Opt<HashNode<K, V>> = None<HashNode<K, V>>();
          = opt;
        })),
      0)
}

fn add<K, V, H, E>(map &HashMap<K, V, H, E>, key K, value V) Void {
  if (map.has(key)) {
    panic("Map already has given key!");
  }
  if ((map.size + 1) * 2 >= map.table.len()) {
    newSize =
        if (map.table.len() == 0) { 2 }
        else { map.table.len() * 2 };
    newTable =
        Array<mut, Opt<HashNode<K, V>>>(
            newSize,
            &IFunction1<mut, Int, Opt<HashNode<K, V>>>((index){
              opt Opt<HashNode<K, V>> = None<HashNode<K, V>>();
              = opt;
            }));
    i = 0;
    while (i < map.table.len()) {
      if (map.table[i].empty?()) {
        // do nothing
      } else {
        node? = (mut map.table[i] = None<HashNode<K, V>>());
        node = get(node?);
        addNodeToTable(&newTable, map.hasher, node);
      }
      mut i = i + 1;
    }
    mut map.table = newTable;
  }

  addNodeToTable(map.table, map.hasher, HashNode<K, V>(key, value));
  mut map.size = map.size + 1;
}

fn addNodeToTable<K, V, H>(table &Array<mut, Opt<HashNode<K, V>>>, hasher H, node HashNode<K, V>) {
  hash = (hasher)(node.key);
  startIndex = abs(hash mod table.len());
  index = findEmptyIndexForKey(table, startIndex, node.key);

  opt Opt<HashNode<K, V>> = Some(node);
  mut table[index] = opt;
}

fn findEmptyIndexForKey<K, V>(table &Array<mut, Opt<HashNode<K, V>>>, startIndex Int, key K) Int {
  i = 0;
  while (i < table.len()) {
    index = (startIndex + i) mod table.len();
    something = table[index];
    if (something.empty?()) {
      ret index;
    }
    // continue to next node
    mut i = i + 1;
  }
  = panic("findEmptyIndexForKey went past end of table!");
}

fn findIndexOfKey<K, V, E>(table &Array<mut, Opt<HashNode<K, V>>>, equator E, startIndex Int, key K) Opt<Int> {
  i = 0;
  while (i < table.len()) {
    index = (startIndex + i) mod table.len();
    something = table[index];
    if (something.empty?()) {
      ret None<Int>();
    }
    node = something.get();
    if ((equator)(node.key, key)) {
      ret Some<Int>(index);
    }
    // continue to next node
    mut i = i + 1;
  }
  = panic("findIndexOfKey went past end of table! len " + Str(table.len()) + " and i " + Str(i));
}

fn get<K, V, H, E>(self &HashMap<K, V, H, E>, key K) Opt<&V> {
  if (self.table.len() == 0) {
    ret None<&V>();
  }
  hash = (self.hasher)(key);
  startIndex = abs(hash mod self.table.len());
  index? = findIndexOfKey(self.table, self.equator, startIndex, key);
  if (index?.empty?()) {
    opt Opt<&V> = None<&V>();
    ret opt;
  }
  node = self.table[index?.get()].get();
  opt Opt<&V> = Some<&V>(node.value);
  ret opt;
}

fn has<K, V, H, E>(self &HashMap<K, V, H, E>, key K) Bool {
  not(self.get(key).empty?())
}

fn keys<K, V, H, E>(self &HashMap<K, V, H, E>) Array<imm, K> {
  list = List<K>();
  index = 0;
  while (index < self.table.len()) {
    node? = self.table[index];
    if (not(node?.empty?())) {
      list.add(node?.get().key);
    }
    mut index = index + 1;
  }
  = list.toArray<imm>();
}



fn toArray<M, N, E, SM>(seq &[<SM> N * E]) rules(M Mutability) {
  Array<M, E>(N, &IFunction1<SM, Int, E>((i){ seq[i]}))
}

//fn each<N, E, F, M>(seq &[<M> N * E], func F) Void {
//  Array<mut, Int>(N, &IFunction1<mut, Int, Int>((i){ func(seq[i]); = 0; }));
//}

//fn map<M>(seq &[<_> N * E], func F) rules(M Mutability) {
//  Array<M>(N, (i){ func(seq[i]) })
//}

//fn each<E, F>(arr &Array<_, E>, func F) Void {
//  Array<mut, Int>(arr.len(), &IFunction1<mut, Int, Void>((i){ func(arr[i]); = 0; }));
//}

//fn map<M>(arr &Array<_, E>, func F) rules(M Mutability) {
//  Array<M>(arr.len(), (i){ func(arr[i]) })
//}

fn has<E, F>(arr &Array<_, E>, elem E, equator F) Bool {
  i = 0;
  while (i < arr.len()) {
    if ((equator)(arr[i], elem)) {
      ret true;
    }
    mut i = i + 1;
  }
  = false;
}

fn has<E>(arr &Array<_, E>, elem E) Bool {
  has(arr, elem, ==)
}

fn has<E, F>(seq &[<_> _ * E], elem E, equator F) Bool {
  i = 0;
  while (i < seq.len()) {
    if ((equator)(seq[i], elem)) {
      ret true;
    }
    mut i = i + 1;
  }
  = false;
}

fn has<E>(seq &[<_> _ * E], elem E) Bool {
  has(seq, elem, ==)
}

fn Arr<M, F>(n Int, generator &F) Array<M, T>
rules(M Mutability, T Ref, Prot("__call", (&F, Int), T))
{
  Array<M>(n, &IFunction1<mut, Int, T>(generator))
}

fn each<M, T, F>(arr &Array<M, T>, func F) Void {
  i! = 0;
  l = len(&arr);
  while (i < l) {
    func(arr[i]);
    mut i = i + 1;
  }
}

fn indices<>(arr &Array<_, _>) Array<imm, Int> {
  Arr<imm>(len(arr), {_})
}

fn eachI<F>(arr &Array<_, _>, func F) Void {
  i! = 0;
  l = len(&arr);
  while (i < l) {
    func(i, arr[i]);
    mut i = i + 1;
  }
}



struct Vec2 imm {
  x Float;
  y Float;
}

struct Vec3 imm {
  x Float;
  y Float;
  z Float;
}

struct Location imm {
  groupX Int;
  groupY Int;
  indexInGroup Int;
}

struct Pattern imm {
  name Str;
  cornersByShapeIndex Array<imm, Array<imm, Vec2>>;
  patternTiles Array<imm, PatternTile>;
  xOffset Vec2;
  yOffset Vec2;
}

struct PatternTile imm {
  shapeIndex Int;
  rotateRadians Float;
  translate Vec2;
  sideAdjacenciesBySideIndex Array<imm, PatternSideAdjacency>;
  cornerAdjacenciesByCornerIndex Array<imm, Array<imm, PatternCornerAdjacency>>;
}

struct PatternSideAdjacency imm {
  groupRelativeX Int;
  groupRelativeY Int;
  tileIndex Int;
  sideIndex Int;
}

struct PatternCornerAdjacency imm {
  groupRelativeX Int;
  groupRelativeY Int;
  tileIndex Int;
  cornerIndex Int;
}


struct TerrainTile {
  elevation Int;
  walkable Bool;
  classId Str;
}

struct LocationHasher { }
fn __call(this &LocationHasher, loc Location) {
  hash! = 0;
  mut hash = 41 * hash + loc.groupX;
  mut hash = 41 * hash + loc.groupY;
  mut hash = 41 * hash + loc.indexInGroup;
  = hash;
}

struct LocationEquator { }
fn __call(this &LocationEquator, a Location, b Location) {
  (a.groupX == b.groupX) and (a.groupY == b.groupY) and (a.indexInGroup == b.indexInGroup)
}

struct Terrain {
  pattern Pattern;
  elevationStepHeight Float;
  tiles HashMap<Location, TerrainTile, LocationHasher, LocationEquator>;
}

fn makeBoard() Array<mut, Array<mut, Str>> {
  ret
    Arr<mut>(10, (row){
      Arr<mut>(10, (col){
        = if (row == 0) { "#" }
          else if (col == 0) { "#" }
          else if (row == 9) { "#" }
          else if (col == 9) { "#" }
          else { "." }
      })
    });
}

fn display(board &Array<mut, Array<mut, Str>>, playerRow Int, playerCol Int) {
  toPrint! = "";
  eachI &board (rowI, row){
    eachI &row (cellI, cell){
      if (and(rowI == playerRow, cellI == playerCol)) {
        mut toPrint = toPrint + "@";
      } else {
        mut toPrint = toPrint + cell;
      }
    }
    mut toPrint = toPrint + "\n";
  }
  print(toPrint);
}

fn main() {
  board = makeBoard();

  playerRow! = 4;
  playerCol! = 3;

  running! = true;
  while (running) {
    display(&board, playerRow, playerCol);

    key = __getch();
    println(key);
    newPlayerRow! = playerRow;
    newPlayerCol! = playerCol;
    if (key == 81) {
      mut running = false;
    } else if (key == 119) {
      mut newPlayerRow = newPlayerRow - 1;
    } else if (key == 115) {
      mut newPlayerRow = newPlayerRow + 1;
    } else if (key == 97) {
      mut newPlayerCol = newPlayerCol - 1;
    } else if (key == 100) {
      mut newPlayerCol = newPlayerCol + 1;
    }
    if (board[newPlayerRow][newPlayerCol] == ".") {
      mut playerRow = newPlayerRow;
      mut playerCol = newPlayerCol;
    }
  }
}




