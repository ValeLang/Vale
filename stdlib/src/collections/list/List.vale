import stdlib.stringutils.*;
import stdlib.arrays.*;

#!DeriveStructDrop
struct List<E Ref> {
  array! Array<mut, E>;
}

func List<E>(capacity int) List<E> {
  List<E>(Array<mut, E>(capacity))
}

func List<E>() List<E> {
  List<E>(0)
}

func List<'s rw, E, V, N>(
  source_arr 's [#N]<mut, V>E) // HGM: live
'o List<E> {
  list_arr = 'o Array<mut, E>(source_arr.len()); // No overhead, source_arr is own

  migrate(source_arr, &list_arr);
  // O(2n) checks, but we should replace this with a primitive which
  // would reduce it to 2 checks
  // HGM: would further reduce this to zero checks.

  return List<E>(list_arr);
}

pure func List<'r imm, 'o rw, E Ref imm, V, N>(
  source_arr 'r [#N]<imm, V>E)
'o List<E> {
  list_arr = Array<mut, E>(source_arr.len());

  i = 0;
  while i < source_arr.len() {
    list_arr.push(source_arr[i]); // No overhead, source_arr is pure
    set i = i + 1;
  }

  return List<E>(list_arr);
}

func drop<E>(
  self List<E>)
void
where func drop(E)void {
  [array] = self;
  drop(array);
}

pure func len<'r imm, E>(
  list 'r &List<E>)
int {
  len(&list.array) // No overhead, list is pure
}

func add<'l rw, E>(
  list 'l &List<E>, // live
  newElement E)
void {
  list.maybeExpand();
  list.array.push(newElement); // 2 overhead
  // static analysis would reduce it to 1
  // HGM: would reduce it to 0
}

func add<'l rw, E>(
  list 'l List<E>,
  newElement E)
'l List<E> {
  list.add(newElement); // 0 overhead: own sender, live receiver
  return list;
}

func maybeExpand<'l rw, E>(
  list 'l &List<E>) // live
void {
  oldCapacity = list.array.capacity(); // 2 checks.
  // static analysis would reduce it to 1
  // HGM would reduce it to 0

  if list.len() == oldCapacity { // 1 check, HGM: 0
    newCapacity = if (oldCapacity > 0) { oldCapacity * 2 } else { 1 };
    newArray = Array<mut, E>(newCapacity);
    oldArray = set list.array = newArray; // 1 check, HGM: 0
    migrate(oldArray, &list.array); // 2 checks, HGM: 0
  }
}

pure func get<'l imm, E>(
  list 'l &List<E>,
  index int)
&E {
  a = list.array; // 0 checks, list pure
  a[index] // 0 checks, a pure
}

func each<'l rw, E, F>(
  list 'l &List<E>, // live
  func F)
void
where func drop(F)void,
      func(&F, &E)void
{
  i = 0;
  n = len(list); // 1 check. HGM: zero
  while i < n {
    func(list.get(i)); // O(n) checks. HGM: zero
    set i = i + 1;
  }
}

// There might be an opportunity to optimize this... if we can know that the given functor is
// pure then this can be pure as well.
// Can we inherit the purity of that lambda somehow?
func map<'l rw, 'o rw, T, E, F>(
  list 'l &List<E>, // live
  func &F) // live
'o List<T>
where func(&F, &E)T {
  result = List<T>();

  // list.each({ result.add((func)(_)); });

  i = 0;
  n = len(list); // 1 check. HGM: zero
  while i < n {
    result.add(func(list.get(i))); // O(2n) checks (func, and list.get). HGM: zero
    set i = i + 1;
  }

  return result;
}

pure func toImmArray<'l imm, 'o rw, E Ref imm>(
  list 'l &List<E>)
'o Array<imm, E> {
  'o Array<imm, E>(
      list.len(), // no checks, pure
      &{ list.get(_) }) // O(n) checks because it's calling this borrow lambda every time, list is pure though.
  // 0 if we can send in an owning lambda.
  // or 0 if we have HGM and Array takes in a live lambda
}

pure func toImmArray<'l, E Ref imm>(
  list List<E>)
Array<imm, E>
where func drop(E)void {
  [arr] = list;
  Array<imm, E>(
      arr.len(), // no checks, pure
      &{ arr[_] }) // O(n) checks because it's calling this borrow lambda every time, list is pure though.
  // 0 if we can send in an owning lambda.
  // or 0 if we have HGM and Array takes in a live lambda
}


func set<E>(
  list &List<E>,
  index int,
  value E)
E {
  set list.array[index] = value
  // 1 check. could do live here... not sure if worth it though.
  // this would be a good candidate for inlining, and some sort of optimizer
}

func remove<E>(
  list &List<E>,
  removeAtIndex int)
E {
  if removeAtIndex < 0 {
    panic("Can't remove at negative index!");
  }
  if removeAtIndex >= list.len() {
    panic("Can't remove, index out of bounds!");
  }

  // live
  arr = list.arr; // 1 check

  temp Opt<E> = Some<E>(arr.pop()); // 1 check, HGM: 0
  i = arr.len() - 1; // 1 check, HGM: 0
  while i >= removeAtIndex {
    // O(n) checks for the arr[i]
    // HGM: 0, but O(n) if we move the elements and theyre lockable.
    (set temp = Some(set arr[i] = (set temp = None<E>()).get())).expect_none();
    set i = i - 1;
  }

  return (temp).get();
}

pure func indexOf<l', o', E>(
  list l'&List<E>,
  element &E)
o'Opt<int>
where func ==(&E, &E)bool {
  i = 0;
  l = len(&list); // 0 checks
  while i < l {
    if list.get(i) == element { // 0 checks
      return o'Some(i);
    }
    set i = i + 1;
  }
  return o'None<int>();
}

pure func indexWhere<E, F>(
  list &List<E>,
  func F)
Opt<int>
where func(&F, &E)bool, func drop(F)void {
  i = 0;
  l = len(&list);
  while i < l {
    if func(list.get(i)) {
      return Some(i);
    }
    set i = i + 1;
  }
  return None<int>();
}

func contains<E>(list &List<E>, element &E) bool
where func ==(&E, &E)bool {
  i = 0;
  l = len(&list);
  while i < l {
    if list.get(i) == element {
      return true;
    }
    set i = i + 1;
  }
  return false;
}

func reverse<E>(list List<E>) List<E> {
  [arr] = list;
  dest = Array<mut, E>(arr.capacity());
  drop_into(arr, &{ dest.push(_); });
  return List(dest);
}


func exists<E, F>(list &List<E>, func F) bool
where func(&F, &E)bool, func drop(F)void {
  i = 0;
  while i < list.len() {
    if (&func)(list.get(i)) {
      return true;
    }
    set i = i + 1;
  }
  return false;
}

//func List<E, M>(arr &Array<M, E>) List<E> {
//  list = List<E>();
//  foreach elem in arr {
//    list.add(elem);
//  }
//  list
//}

func toArray<E>(list List<E>) []<mut>E {
  [arr] = list;
  return arr;
}

func toArray<E>(list &List<E>) []<mut>&E {
  return Array<mut, &E>(list.len(), { list.get(_) });
}

func clone<E>(list &List<E>) List<E>
where func clone(&E)E {
  return List<E>(Array<mut, E>(list.len(), { list.get(_).clone() }));
}



// below here is old List code

//func toArray<E>(list List<E>) Array<mut, E> {
//  [x] = list;
//  x
//}
//func toArray<E>(list &List<E>) Array<mut, E> {
//  toVaryArray(list)
//}
//func toVaryArray<E>(list &List<E>) Array<mut, E> {
//  Array<mut, E>(list.len(), &(i) => { list.get(i) })
//}

//func toList<E>(arr *Array<_, E>) List<E> {
//  list = List<E>();
//  arr each (elem){
//    list.add(elem);
//  };
//  = list;
//}

//func eachI<E, F>(list &List<E>, func F) void {
//  i = 0;
//  l = len(*list);
//  while i < l {
//    func(i, list.get(i));
//    set i = i + 1;
//  }
//}
//
//func contains<E>(list &List<E>, element E) bool {
//  i = 0;
//  l = len(*list);
//  while i < l {
//    if list.get(i) == element {
//      return true;
//    }
//    set i = i + 1;
//  }
//  return false;
//}
//
//
//import stdlib.*;
//
//struct List<E> rules(E Ref) {
//  array! Array<mut, Opt<E>>;
//  size! int;
//}
//func List<E>() List<E>
//rules(E Ref) {
//  List<E>([vary *](0, (index){ __pretend<Opt<E>>() }), 0)
//}
//func len<E>(list &List<E>) int { list.size }
//func add<E>(list &List<E>, newElement E) {
//  if list.size == list.len() {
//    newLen = if (len(&list) == 0) { 1 } else { len(&list) * 2 };
//    newArray =
//       [vary *](newLen, &IFunction1<mut, int, Opt<E>>((index){
//          res Opt<E> = if (index < len(&list)) {
//              result Opt<E> = (set list.array[index] = None<E>());
//              = result;
//            } else {
//              result Opt<E> = None<E>();
//              = result;
//            };
//          return res;
//        }));
//    set list.array = newArray;
//  }
//  set list.array[list.size] = Some<E>(newElement);
//  set list.size = list.size + 1;
//}

//func set<E>(list &List<E>, index int, value E) void {
//  set list.array[index] = Some(value);
//}
//func toArray<E>(list &List<E>) Array<mut, E> {
//  [*](list.len(), &(i){ list.get(i) })
//}

//func toImmArray<E>(list &List<E>) Array<imm, E> {
//  [imm *](list.len(), &(i){ list.get(i) })
//}
//// deprecate
//func toList<E>(arr &Array<_, _, E>) List<E> {
//  list = List<E>();
//  arr each (elem){
//    list.add(elem);
//  };
//  = list;
//}

//func enumerate<E, F>(self &List<E>, func F) void {
//  i = 0;
//  l = self.len();
//  while i < l {
//    func(self.get(i), i);
//    set i = i + 1;
//  }
//}
//

//
//func remove<E>(list &List<E>, removeAtIndex int) E {
//  if removeAtIndex < 0 {
//    panic("Can't remove at negative index!");
//  }
//  if removeAtIndex >= list.size {
//    panic("Can't remove, index out of bounds!");
//  }
//
//  temp = (set list.array[list.size - 1] = None<E>());
//  i = list.size - 2;
//  while i >= removeAtIndex {
//    set temp = (set list.array[i] = (set temp = None<E>()));
//    set i = i - 1;
//  }
//
//  set list.size = list.size - 1;
//
//  return (temp).get();
//}
//

func join(list &List<str>) str { join(list, "") }
func join(list &List<str>, joiner str) str {
  combined = StringBuilder();
  first = true;
  foreach x in list {
    if not first {
      combined.print(joiner);
    }
    combined.print(x);
    set first = false;
  }
  return combined.str();
}

func join(list &List<StrSlice>) str { join(list, "") }
func join(list &List<StrSlice>, joiner str) str {
  combined = StringBuilder();
  first = true;
  foreach x in list {
    if not first {
      combined.print(joiner);
    }
    combined.print(x);
    set first = false;
  }
  return combined.str();
}


//func print<T>(list &List<T>) {
//  print("List(");
//  first = true;
//  each (&list) {
//    if not first {
//      print(", ");
//    }
//    set first = false;
//    print(_);
//  }
//  print(")");
//}
//
//func println<T>(list &List<T>) {
//  print(list);
//  println("");
//}
