
interface MyOption sealed imm { }

struct MySome imm {
  value @MyList;
}
impl MyOption for MySome;

struct MyNone imm { }
impl MyOption for MyNone;


struct MyList imm {
  value @int;
  next @MyOption;
}

fn sum(list @MyList) int {
  ret list.value + sum(list.next);
}

fn sum(virtual opt @MyOption) int abstract;
fn sum(opt @MyNone impl MyOption) int { ret 0; }
fn sum(opt @MySome impl MyOption) int {
   ret sum(opt.value);
}


fn main() int export {
  list = MyList(7, MySome(MyList(17, MySome(MyList(18, MyNone())))));
  ret sum(list);
}
