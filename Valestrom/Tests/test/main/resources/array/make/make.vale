
fn MakeArray<T, G>(n int, generator G) Array<mut, T>
rules(
  T Ref,
  G Ref(share | borrow, _, _),
  F Prot = Prot("__call", (G, int), T))
{
  arr = Array<mut, T>(n);
  i! = 0;
  while (i < n) {
    arr!.push(generator!(i));
    set i = i + 1;
  }
  ret arr;
}

fn MakeVaryArray<T, G>(n int, generator G) Array<mut, T>
rules(
  T Ref,
  G Ref(share | borrow, _, _),
  F Prot = Prot("__call", (G, int), T))
{
  arr = Array<mut, T>(n);
  i! = 0;
  while (i < n) {
    arr!.push(generator!(i));
    set i = i + 1;
  }
  ret arr;
}

fn MakeImmArray<G>(n int, generator G) Array<imm, T>
rules(
  T Ref,
  G Ref(share | borrow, _, _),
  F Prot = Prot("__call", (G, int), T))
{
  ret Array<imm, T>(n, generator);
}

fn toImmArray<N, E>(seq &[<_, _> N * E]) Array<imm, E> {
  ret MakeImmArray(N, { seq[_] });
}

fn toImmArray<T>(source &Array<_, T>) Array<imm, *T> {
  ret MakeImmArray(source.len(), &!{ source[_] });
}

fn toVaryArray<N, E, SM>(seq &[<SM> N * E]) Array<mut, E> {
  ret MakeVaryArray(N, { seq[_] });
}

fn toVaryArray<T>(source &Array<_, T>) Array<mut, *T> {
  ret MakeVaryArray(source.len(), &!{ source[_] });
}

fn toArray<T>(source &Array<_, T>) Array<mut, *T> {
  ret MakeArray(source.len(), { source[_] });
}
